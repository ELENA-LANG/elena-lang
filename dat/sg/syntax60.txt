__define eof                 8195;
__define identifier         12292;
__define integer            12293;
__define string             12294;
__define hexinteger         12295;
__define reference          12296;
__defineterminal "}"        12297;
__define character          12298;
__define global		    12299;
__define wide               12300;
__define constant           12301;
__define long               12302;
__define real               12303;

__define DECLARATION         5120;
__define BLOCK               7184;
__define NO_BODY             7185;
__define TEMPLATE_BLOCK      4104;
__define PARAMETER           4106;
__define END_OF_BLOCK        4107;
__define DICTIONARY          4128;
__define META_STATEMENT      4129;
__define INCLUDE_STATEMENT   4130;
__define RELOAD_STATEMENT    4131;
__define OBJECT              4145;
__define TEMPLATE_TYPE       4146;
__define ARRAY_TYPE          4147;
__define NESTED              4224;
__define CLOSURE             4225;
__define MESSAGE             4288;
__define OPERATOR            4310;
__define SUB_VARIABLE        4311;
__define RET_EXPRESSION      7220;
__define GET_EXPRESSION      7222;
__define INIT_EXPRESSION     7223;
__define ACCUM_EXPRESSION    7225;
__define NESTED_EXPRESSION   6197;
__define INDEXER_OPERATION   6209;
__define ASSIGN_OPERATION    6210;
__define ADDITION_ASSIGNMENT 6211;
__define ADD_OPERATION       6212;
__define SUB_OPERATION       6213;
__define LEN_OPERATION       6214;
__define IF_OPERATION        6215;
__define LESS_OPERATION      6216;
__define NAME_OPERATION      6217;
__define EQUAL_OPERATION     6218;
__define NOT_OPERATION       6219;
__define NOTEQUAL_OPERATION  6220;
__define LOOP_OPERATION      6221;
__define ELSE_OPERATION         6222;
__define IF_ELSE_OPERATION      6223;
__define MUL_OPERATION          6224;
__define DIV_OPERATION          6225;
__define NOTLESS_OPERATION      6226;
__define GREATER_OPERATION      6227;
__define NOTGREATER_OPERATION   6228;
__define EXTERN_OPERATION       6229;
__define NEGATE_OPERATION       6230;
__define VALUE_OPERATION        6231;
__define BAND_OPERATION         6232;
__define BOR_OPERATION          6233;
__define BXOR_OPERATION         6234;
__define BNOT_OPERATION         6235;
__define SHL_OPERATION          6236;
__define SHR_OPERATION          6237;
__define SUB_ASSIGNMENT         6238;
__define MUL_ASSIGNMENT         6239;
__define DIV_ASSIGNMENT         6240;
__define AND_OPERATION          6241;
__define OR_OPERATION           6242;
__define XOR_OPERATION          6243;
__define BREAK_OPERATION        6244;
__define LAZY_OPERATION         6245;
__define TUPLE_ASSIGNING        6246;
__define CONTINUE_OPERATION     6247;
__define YIELD_OPERATION        6248;
__define REFER_OPERATION        6251;
__define MESSAGE_OPERATION      6337;
__define PROPERTY_OPERATION     6340;
__define EXPRESSION             6288;
__define L5_EXPRESSION          6289;
__define SINGLE_EXPRESSION      6290;
__define L8_EXPRESSION          6291;
__define ROOT_EXPRESSION        6292;
__define L6_EXPRESSION          6293;
__define T_EXPRESSION           6294;
__define L4_EXPRESSION          6295;
__define NT_EXPRESSION          6296;
__define L7_EXPRESSION          6297;
__define L3_SINGLE_EXPRESSION   6298;
__define NESTED_ROOT_EXPRESSION 6299;
__define OPERATION_TEMPLATE     6300;
__define LT_EXPRESSION          6301;
__define SWITCH_OPTION 	        6353;
__define SWITCH_LAST_OPTION     6354;
__define SWITCH_CODE 	        6355;
__define COLLECTION_EXPRESSION  6356;
__define TUPLE_COLLECTION 	6357;
__define POSTFIX                4201;
__define TEMPLATE_POSTFIX       4202;
__define TEMPLATE_ARG           4208;
__define DIMENSION              5233;
__define RESEND                 7366;
__define CATCH_OPERATION        7367;
__define CATCH                  7368;
__define FINAL_OPERATION        7386;
__define REDIRECT               7371;
__define ALT_OPERATION          7372;
__define ISNIL_OPERATION        7373;
__define SWITCH_OPERATION       7376;
__define COMPLEX_NAME 	        4302;
__define INLINE                 4303;
__define SUB_DECLARATION        4312;
__define FINALLY                7385;
__define PARAMETER_BLOCK        4336;

START ::= 
	{ DECLARATION | META_DECLARATION }+ eof
	| eof;

META_DECLARATION ::=
	"#new" DICTIONARY DECLARATION_END
	| "#let" META_STATEMENT DECLARATION_END
	| "#include" INCLUDE_STATEMENT  DECLARATION_END
	| "#reload" RELOAD_STATEMENT DECLARATION_END;	

DECLARATION ::=
	{ identifier | reference }+ IR_DECLARATION;

IR_DECLARATION ::=
	{ TEMPLATE_BRACKETS identifier? | { DYNAMIC_DIMENSION ^ARRAY_TYPE }+ identifier } { POSTFIXES NESTED_SCOPE | SCOPE }
	| { "," SUB_DECLARATION }+ { POSTFIXES NESTED_SCOPE | SCOPE }
	| { "::" COMPLEX_NAME }+ TEMPLATE_BRACKETS? METHOD_SCOPE
	| POSTFIXES NESTED_SCOPE
	| SCOPE;

SUB_DECLARATION ::=
	{ identifier | reference }+ { TEMPLATE_BRACKETS identifier? | { DYNAMIC_DIMENSION ^ARRAY_TYPE }+ identifier | eps };

DICTIONARY ::=
	identifier+;

META_STATEMENT ::=
	EXPRESSION;

RELOAD_STATEMENT ::=
	identifier;

INCLUDE_STATEMENT ::=
	{ identifier | reference }+ ^ OBJECT;

NESTED_SCOPE ::=
	"{" { DECLARATION | META_DECLARATION }* END_OF_BLOCK
	| "=" GET_EXPRESSION DECLARATION_END
	| DECLARATION_END;

SCOPE ::=
        "=" GET_EXPRESSION DECLARATION_END
	| ":=" INIT_EXPRESSION DECLARATION_END
	| "+=" ACCUM_EXPRESSION DECLARATION_END
	| "{" { DECLARATION | META_DECLARATION }* END_OF_BLOCK
	| "[" DIMENSION "]" DECLARATION_END
	| METHOD_SCOPE
        | DECLARATION_END;

METHOD_SCOPE ::=
	"(" { PARAMETER { "," PARAMETER }* }? ")" POSTFIXES? METHOD_BODY;

POSTFIXES ::=
	":" POSTFIX { "," POSTFIX }*;

METHOD_BODY ::=
	"{" BLOCK
	| "=" RET_EXPRESSION DECLARATION_END
	| "<=" RESEND { DECLARATION_END | "{" BLOCK }
	| "=>" REDIRECT DECLARATION_END
	| NO_BODY;

NO_BODY ::=
	";";

BLOCK ::=
	STATEMENT NEXT_STATEMENT
	| "^" RET_EXPRESSION LAST_STATEMENT 
	| END_OF_BLOCK;

LAST_STATEMENT ::=
	DECLARATION_END END_OF_BLOCK
	| END_OF_BLOCK;

NEXT_STATEMENT ::=
	DECLARATION_END { 
		STATEMENT NEXT_STATEMENT 
		| "^" RET_EXPRESSION LAST_STATEMENT 
		| END_OF_BLOCK }
	| END_OF_BLOCK;

STATEMENT ::=
	ROOT_EXPRESSION
	| "#include" INCLUDE_STATEMENT
	| "#let" META_STATEMENT
	| "#new" DICTIONARY;

RESEND ::=
	identifier+ RESEND_R;

REDIRECT ::= 
	EXPRESSION;

RET_EXPRESSION ::=
	EXPRESSION;

INIT_EXPRESSION ::=
	EXPRESSION;

ACCUM_EXPRESSION ::=
	EXPRESSION;

GET_EXPRESSION ::=
	EXPRESSION;

T_EXPRESSION ::=
	"{" BLOCK;

T_EXPRESSION_F ::=
	identifier { NT_EXPRESSION T_EXPRESSION_F | LT_EXPRESSION }
	| eps;

NT_EXPRESSION ::=
	"{" BLOCK
	| "::" NESTED_EXPRESSION ^NESTED
	| "(" T_SUB_EXPRESSION;

LT_EXPRESSION ::=
	NESTED_ROOT_EXPRESSION ^ BLOCK;

ROOT_EXPRESSION ::=
        identifier { 
		{ identifier }+ { 
			"," ^OBJECT SUB_VARIABLE { "," SUB_VARIABLE }* ASSIGN EXPRESSION ^TUPLE_ASSIGNING 
			| L0 ^OBJECT L0_R L1_OP?
			| { DYNAMIC_DIMENSION ^ARRAY_TYPE }+ {
				identifier ^OBJECT ASSIGN ASSIGN_R
				| "{" ^OBJECT COLLECTION "}" ^ COLLECTION_EXPRESSION L3_OP*
			}
			| ASSIGN ^OBJECT ASSIGN_R
			| L2 ^OBJECT L2_R L3_OP* { L8_OP | L9_OP }?
			| L3 ^OBJECT MESSAGE {
				L3_R L3_OP*
				| ASSIGN EXPRESSION ^PROPERTY_OPERATION
				| eps ^PROPERTY_OPERATION }
			| eps ^OBJECT }
		| "," ^OBJECT SUB_VARIABLE { "," SUB_VARIABLE }* ASSIGN EXPRESSION ^TUPLE_ASSIGNING 
		| { reference | global } { 
			L3 ^OBJECT MESSAGE L3_R 
			| eps ^OBJECT }
		| L0 ^OBJECT L0_R L0_OP* {
			L1_OP
			| L3 MESSAGE {
				L3_R L3_OP*
				| ASSIGN EXPRESSION ^PROPERTY_OPERATION
				| eps ^PROPERTY_OPERATION }
			| eps }
		| { DYNAMIC_DIMENSION ^ARRAY_TYPE }+ identifier ^OBJECT ASSIGN ASSIGN_R
		| ASSIGN ^OBJECT ASSIGN_R
		| L1a_O_OP
		| L2 ^OBJECT MESSAGE_PARAMETERS? ")" {
			T_EXPRESSION T_EXPRESSION_F ^ TEMPLATE_BLOCK
			| ISNIL ^MESSAGE_OPERATION SINGLE_EXPRESSION ^ISNIL_OPERATION
			| LT_EXPRESSION ^ TEMPLATE_BLOCK
			| TRY ^MESSAGE_OPERATION TRY_R
			| eps ^MESSAGE_OPERATION }
		| L3 ^OBJECT { 
			OPERATOR MESSAGE? L3_R ^OPERATION_TEMPLATE
			| MESSAGE {
				L3_R {
					L3 L3_F
					| L4_OP
					| L6_OP
					| L9_OP
					| eps }
				| ASSIGN EXPRESSION ^PROPERTY_OPERATION
				| L3 ^PROPERTY_OPERATION L3_F
				| EQUAL ^PROPERTY_OPERATION L6_EXPRESSION ^EQUAL_OPERATION L8_OP? L9_OP?
				| eps ^PROPERTY_OPERATION }
		}
		| L4_O_OP L4_OP*
		| L5_O_OP 
		| LESS ^OBJECT TEMPLATE_ARG { "," TEMPLATE_ARG }* ">" ^TEMPLATE_TYPE
			{ 
				L3 ^OBJECT MESSAGE L3_R
				| identifier ^OBJECT { ASSIGN ASSIGN_R }? }
		| L7_O_OP
		| L8_O_OP
		| TRY ^OBJECT TRY_R
		| FNL ^OBJECT FNL_R
		| ALT ^OBJECT ALT_R
		| T_EXPRESSION T_EXPRESSION_F ^ TEMPLATE_BLOCK
		| "=>" ^OBJECT { SWITCH_OPTION+ SWITCH_LAST_OPTION? } ^SWITCH_OPERATION
		| eps ^OBJECT }
	| { reference | global } { 
		L3 ^OBJECT MESSAGE MESSAGE_R
		| eps ^OBJECT }
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT L0_OP* L3_OP* L4_OP* L5_OP* L6_OP? 
	| "!" EXPRESSION ^NOT_OPERATION
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION L3_OP* L4_OP* L5_OP* L6_OP? 
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION
	| "(" SUB_EXPRESSION { 
		"=>" { SWITCH_OPTION+ SWITCH_LAST_OPTION? } ^SWITCH_OPERATION
		| L2_OP L2_OP* L3_OP*
		| L3_OP L3_OP* L7_OP* L8_OP? 
		| L7_OP L7_OP* L8_OP? 
		| L8_OP
		| eps }
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION
	| "$reference" SINGLE_EXPRESSION ^REFER_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION
	| "$rep" EXPRESSION ^LOOP_OPERATION
	| "$ext" EXPRESSION ^EXTERN_OPERATION
	| "$break" ^BREAK_OPERATION
	| "$continue" ^CONTINUE_OPERATION
	| "$yield" EXPRESSION ^YIELD_OPERATION;

NESTED_ROOT_EXPRESSION ::=
        identifier { 
		{ identifier }+ { 
			L0 ^OBJECT L0_R L1_OP?
			| ASSIGN ^OBJECT ASSIGN_R
			| L2 ^OBJECT L2_R L3_OP* { L8_OP | L9_OP }?
			| L3 ^OBJECT MESSAGE {
				L3_R L3_OP*
				| ASSIGN EXPRESSION ^PROPERTY_OPERATION
				| eps ^PROPERTY_OPERATION }
			| eps ^OBJECT }
		| L0 ^OBJECT L0_R {
			L1_OP
			| L3_OP
			| eps }
		| ASSIGN ^OBJECT ASSIGN_R
		| L1a_O_OP
		| L2 ^OBJECT MESSAGE_PARAMETERS? ")" {
			T_EXPRESSION T_EXPRESSION_F ^ TEMPLATE_BLOCK
			| ISNIL ^MESSAGE_OPERATION SINGLE_EXPRESSION ^ISNIL_OPERATION
			| eps ^MESSAGE_OPERATION }
		| L3 ^OBJECT MESSAGE {
			L3_R {
				L3 L3_F
				| L4_OP
				| L6_OP
				| L9_OP
				| eps }
			| ASSIGN EXPRESSION ^PROPERTY_OPERATION
			| eps ^PROPERTY_OPERATION }
		| L4_O_OP L4_OP*
		| L5_O_OP 
		| L7_O_OP
		| TRY ^OBJECT TRY_R
		| T_EXPRESSION T_EXPRESSION_F ^ TEMPLATE_BLOCK
		| "=>" ^OBJECT { SWITCH_OPTION+ SWITCH_LAST_OPTION? } ^SWITCH_OPERATION
		| eps ^OBJECT }
	| { reference | global } { 
		L3 ^OBJECT MESSAGE MESSAGE_R
		| eps ^OBJECT }
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT L4_OP* L5_OP* L6_OP?
	| "!" EXPRESSION ^NOT_OPERATION
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION L3_OP* L4_OP* L5_OP* L6_OP? 
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION
	| "$reference" SINGLE_EXPRESSION ^REFER_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION
	| "$rep" EXPRESSION ^LOOP_OPERATION
	| "$ext" EXPRESSION ^EXTERN_OPERATION
	| "$break" ^BREAK_OPERATION
	| "$continue" ^CONTINUE_OPERATION;

EXPRESSION ::=                                           
        identifier { 
		{ identifier | reference }+ { 
			L0 ^OBJECT L0_R L1_OP?
			| { DYNAMIC_DIMENSION ^ARRAY_TYPE }+ {
				L2 ^OBJECT L2_R L3_OP* L4_OP* L5_OP* L6_OP? L7_OP* L9_OP?
				| "{" ^OBJECT COLLECTION "}" ^ COLLECTION_EXPRESSION L3_OP* }
			| ASSIGN ^OBJECT ASSIGN_R
			| L2 ^OBJECT L2_R L3_OP* L5_OP* L6_OP? L7_OP* { L8_OP | L9_OP }?
			| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP* L4_OP* L5_OP* L6_OP? L7_OP* L9_OP?
			| LESS ^OBJECT TEMPLATE_ARG { "," TEMPLATE_ARG }* ">" ^TEMPLATE_TYPE {
					L0 ^OBJECT L0_R
					| L2 ^OBJECT L2_R L3_OP*
					| L3 ^OBJECT MESSAGE MESSAGE_R 
					| NESTED_EXPRESSION ^NESTED
				}
			| L6_O_OP_WM
			| NESTED_EXPRESSION ^NESTED L3_OP*
			| eps ^OBJECT }
		| L0 ^OBJECT L0_R L0_OP* {
			L1_OP
			| L3_OP L5_OP*
			| L5_OP
			| L6_OP
			| eps }
		| ASSIGN ^OBJECT ASSIGN_R
		| L1a_O_OP
		| L2 ^OBJECT L2_R L3_OP* L4_OP* L5_OP* L6_OP? L7_OP* L9_OP?
		| L3 ^OBJECT { MESSAGE MESSAGE_R | OPERATOR MESSAGE L3_R ^OPERATION_TEMPLATE } L3_OP* L4_OP* L5_OP* L6_OP? L7_OP* { L8_OP | L9_OP }?
		| L4_O_OP L4_OP* L5_OP* L6_OP? L7_OP* L9_OP?
		| L5_O_OP L5_OP* L6_OP? L7_OP* L9_OP?
		| L6_O_OP L7_OP* L8_OP?
		| L7_O_OP
		| L8_O_OP
		| TRY ^OBJECT TRY_R
		| NESTED_EXPRESSION ^NESTED L3_OP*
		| eps ^OBJECT }
	| { reference | global } { 
		L3 ^OBJECT MESSAGE MESSAGE_R
		| eps ^OBJECT }
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT L0_OP* L3_OP* L4_OP* L5_OP* L6_OP?
	| "(" SUB_EXPRESSION L2_OP? L3_OP* L4_OP* L5_OP* L6_OP? L7_OP* L8_OP?
	| "{" BLOCK ^CLOSURE
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION L3_OP* L4_OP* L5_OP* L6_OP? 
	| "!" EXPRESSION ^NOT_OPERATION
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION
	| "$reference" SINGLE_EXPRESSION ^REFER_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION
	| "$lazy" NESTED_SUB_EXPRESSION ^EXPRESSION ^LAZY_OPERATION;

NESTED_SUB_EXPRESSION ::=
	identifier { 
		{ identifier }+ { 
			L0 ^OBJECT L0_R L1_OP?
			| ASSIGN ^OBJECT ASSIGN_R
			| L2 ^OBJECT L2_R L3_OP* { L8_OP | L9_OP }?
			| NESTED_EXPRESSION ^NESTED L3_OP*
			| eps ^OBJECT }
		| L0 ^OBJECT L0_R
		| ASSIGN ^OBJECT ASSIGN_R
		| L2 ^OBJECT L2_R L9_OP?
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP* L4_OP* L5_OP* L6_OP? L9_OP?
		| L4_O_OP
		| L5_O_OP
		| eps ^OBJECT }
	| { reference | global } ^OBJECT
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT L0_OP* L4_OP* L5_OP* L6_OP?;

SUB_EXPRESSION ::=
	identifier { 
		identifier+ {
			L2 ^OBJECT L2_R L3_OP* L5_OP* { L8_OP | L9_OP }? ")"
			| { DYNAMIC_DIMENSION ^ARRAY_TYPE }+ {
				L2 ^OBJECT L2_R L3_OP* L4_OP* L5_OP* L6_OP? L7_OP* L9_OP?
				| "{" ^OBJECT COLLECTION "}" ^ COLLECTION_EXPRESSION L3_OP* } ")"
			| "," ^ PARAMETER PARAMETER { "," PARAMETER }* { 
				"=>" RET_EXPRESSION ^CLOSURE ")" ^EXPRESSION
 				| ")" "{" BLOCK ^CLOSURE ^EXPRESSION }
			| ")" {
				"{" ^ PARAMETER BLOCK ^CLOSURE ^EXPRESSION
				| eps ^OBJECT ^EXPRESSION }
		}
		| L0 ^OBJECT L0_R L3_OP* L5_OP* L6_OP? ")"
		| L2 ^OBJECT L2_R L3_OP* L4_OP* L5_OP* L6_OP? L7_OP* L9_OP? ")"
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP* L4_OP* L5_OP* L6_OP? L7_OP* L9_OP? ")"
		| L4_O_OP L4_OP* L5_OP* ")"
		| L5_O_OP ")" 
		| L6_O_OP L7_OP* ")"
		| L7_O_OP ")"
		| "=>" ^ PARAMETER RET_EXPRESSION ^CLOSURE ")" ^EXPRESSION
		| "," ^ OBJECT ^ EXPRESSION EXPRESSION { "," EXPRESSION }* 
			{ "=>" ^ PARAMETER_BLOCK RET_EXPRESSION ^CLOSURE ")" ^EXPRESSION
			| ")" ^ PARAMETER_BLOCK "{" BLOCK ^CLOSURE ^EXPRESSION }
		| ")" {
			"{" ^ PARAMETER BLOCK ^CLOSURE ^EXPRESSION
			| eps ^OBJECT ^EXPRESSION }
	}
	| { reference | global } { 
		L3 ^OBJECT MESSAGE MESSAGE_R ")"
		| ")" ^OBJECT }
	| { string | integer | hexinteger | long | constant | character | wide } ^OBJECT L4_OP* L5_OP* L6_OP? {
		"," ^EXPRESSION EXPRESSION { "," EXPRESSION }* ^ TUPLE_COLLECTION
		| eps
	}  ")" ^EXPRESSION

	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION ")" ^EXPRESSION
	| "!" EXPRESSION ^NOT_OPERATION ")" ^EXPRESSION
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION ^EXPRESSION
	| "$reference" SINGLE_EXPRESSION ^REFER_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION;

T_SUB_EXPRESSION ::=
	identifier+ {
		"," ^ PARAMETER PARAMETER { "," PARAMETER }* { 
 			")" "{" BLOCK ^CLOSURE ^EXPRESSION }
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP* L4_OP* L5_OP* L6_OP? L7_OP* L9_OP? ")" ^EXPRESSION
		| L6_O_OP ")" ^EXPRESSION
		| ")" {
			"{" ^ PARAMETER BLOCK ^CLOSURE ^EXPRESSION
			| eps ^OBJECT ^EXPRESSION 
		}
	};

SUB_SINGLE_EXPRESSION ::=
	identifier { 
		{ identifier }+ { 
			L0 ^OBJECT L0_R L1_OP?
			| ASSIGN ^OBJECT ASSIGN_R
			| L2 ^OBJECT L2_R L3_OP* { L8_OP | L9_OP }?
			| NESTED_EXPRESSION ^NESTED L3_OP*
			| eps ^OBJECT } ")"
		| L0 ^OBJECT L0_R  ")"
		| ASSIGN ^OBJECT ASSIGN_R  ")"
		| L2 ^OBJECT L2_R L9_OP?  ")"
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP* L4_OP* L5_OP* L6_OP? L9_OP? ")"
		| L4_O_OP  ")"
		| L5_O_OP   ")"
		| ")" ^OBJECT }
	| { reference | global } ^OBJECT ")"
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT L4_OP* L5_OP* L6_OP? ")";

SUB_L3_SINGLE_EXPRESSION ::=
	identifier { 
		{ identifier }+ { 
			L0 ^OBJECT L0_R ")"
			| L2 ^OBJECT L2_R L3_OP* ")"
			| NESTED_EXPRESSION ^NESTED L3_OP* ")"
			| LESS TEMPLATE_ARG { "," TEMPLATE_ARG }* ">" ^TEMPLATE_TYPE {
					L0 ^OBJECT L0_R ")"
					| L2 ^OBJECT L2_R L3_OP* ")"
					| NESTED_EXPRESSION ^NESTED ")"
					| identifier ")" "{" ^ PARAMETER BLOCK ^CLOSURE
				}
			| "," ^ PARAMETER PARAMETER { "," PARAMETER }* { 
				"=>" RET_EXPRESSION ^CLOSURE ")" ^EXPRESSION 
				| ")" "{" BLOCK ^CLOSURE ^EXPRESSION 
			}
			| "=>" ^ PARAMETER RET_EXPRESSION ^CLOSURE ")" ^EXPRESSION
			| ")" {
				"{" ^ PARAMETER BLOCK ^CLOSURE
				| eps ^OBJECT }
		}
		| L0 ^OBJECT L0_R ")" 
		| L2 ^OBJECT L2_R L9_OP? ")" 
		| L3 ^OBJECT MESSAGE MESSAGE_R ")" 
		| L4_O_OP L4_OP* ")" 
		| L5_O_OP ")" 
		| "=>" ^ PARAMETER RET_EXPRESSION ^CLOSURE ")" ^EXPRESSION
		| "," ^ PARAMETER PARAMETER { "," PARAMETER }* { 
			"=>" RET_EXPRESSION ^CLOSURE ")" ^EXPRESSION 
			| ")" "{" BLOCK ^CLOSURE ^EXPRESSION }
		| ")" {
			"{" ^ PARAMETER BLOCK ^CLOSURE
			| eps ^OBJECT }
	}
	| { reference | global } ^OBJECT  ")"
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT ")"
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION ")"
	| "!" EXPRESSION ^NOT_OPERATION ")"
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION ")"
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION ")"
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION ")"
	| "$reference" SINGLE_EXPRESSION ^REFER_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION ")";

SINGLE_EXPRESSION ::=
	{ identifier | reference | global }+ ^OBJECT
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT
	| "(" SUB_SINGLE_EXPRESSION;

L4_EXPRESSION ::=
	identifier { 
		{ identifier }+ { 
			L0 ^OBJECT L0_R
			| L2 ^OBJECT L2_R L3_OP*
			| NESTED_EXPRESSION ^NESTED L3_OP*
			| eps ^OBJECT }
		| L0 ^OBJECT L0_R
		| L2 ^OBJECT L2_R
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP*
		| eps ^OBJECT }
	| { reference | global } ^OBJECT 
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT L3_OP*
	| "(" SUB_EXPRESSION
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION L3_OP*
	| "!" L4_EXPRESSION ^NOT_OPERATION
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION
	| "$reference" SINGLE_EXPRESSION ^REFER_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION;

L5_EXPRESSION ::=
	identifier {                     	
		{ identifier }+ { 
			L0 ^OBJECT L0_R
			| L2 ^OBJECT L2_R L3_OP*
			| NESTED_EXPRESSION ^NESTED L3_OP*
			| eps ^OBJECT }
		| L0 ^OBJECT L0_R
		| L2 ^OBJECT L2_R
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP*L4_OP*
		| L4_O_OP L4_OP*
		| eps ^OBJECT }
	| { reference | global } ^OBJECT 
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT L4_OP*
	| "(" SUB_EXPRESSION L3_OP* L4_OP*
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION L3_OP* L4_OP*
	| "!" L5_EXPRESSION ^NOT_OPERATION
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION
	| "$reference" SINGLE_EXPRESSION ^REFER_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION;

L3_F ::=
	MESSAGE {
		L3_R { 
			L3 L3_F 
			| eps }
		| ASSIGN EXPRESSION ^PROPERTY_OPERATION 
		| L3 ^PROPERTY_OPERATION L3_F
		| eps ^PROPERTY_OPERATION
	};

L3_SINGLE_EXPRESSION ::=
	identifier ^OBJECT
	| { reference | global } ^OBJECT 
	| { string | integer | hexinteger | character | constant | long | real } ^OBJECT
	| "(" SUB_L3_SINGLE_EXPRESSION;

L6_EXPRESSION ::=
	identifier { 
		{ identifier }+ { 
			L0 ^OBJECT L0_R
			| L2 ^OBJECT L2_R L3_OP*
			| NESTED_EXPRESSION ^NESTED L3_OP*
			| eps ^OBJECT }
		| L0 ^OBJECT L0_R L3_OP* L4_OP*
		| L2 ^OBJECT L2_R
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP* L4_OP*
		| L4_O_OP L4_OP*
		| L5_O_OP 
		| eps ^OBJECT }
	| { reference | global } ^OBJECT 
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT L4_OP* L5_OP*
	| "(" SUB_EXPRESSION L2_OP? L3_OP* L4_OP* L5_OP*
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION L3_OP* L4_OP* L5_OP*
	| "!" L6_EXPRESSION ^NOT_OPERATION
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION
	| "$reference" SINGLE_EXPRESSION ^REFER_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION;

L7_EXPRESSION ::=
	identifier { 
		{ identifier }+ { 
			L0 ^OBJECT L0_R
			| L2 ^OBJECT L2_R L3_OP*
			| NESTED_EXPRESSION ^NESTED L3_OP*
			| eps ^OBJECT }
		| L0 ^OBJECT L0_R L3_OP* L4_OP* L5_OP* L6_OP?
		| L2 ^OBJECT L2_R
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP* L4_OP* L6_OP?
		| L4_O_OP L4_OP*
		| L5_O_OP 
		| L6_O_OP
		| eps ^OBJECT }
	| { reference | global } ^OBJECT 
	| { string | integer | hexinteger | long | real | constant | character | wide } ^OBJECT L4_OP* L5_OP* L6_OP?
	| "(" SUB_EXPRESSION L6_OP?
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION
	| "!" L7_EXPRESSION ^NOT_OPERATION
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION
	| "$reference" SINGLE_EXPRESSION ^REFER_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION;

L8_EXPRESSION ::=
	"{" BLOCK ^ CLOSURE
	| SINGLE_EXPRESSION;

MESSAGE_PARAMETER ::=
	EXPRESSION;

L0         ::= "[";
ASSIGN     ::= ":=";
L2         ::= "(";
L3         ::= ".";
BAND       ::= "&";
BOR        ::= "|";
BXOR       ::= "^";
STAR       ::= "*";
DIV        ::= "/";
SHL        ::= "$shl";
SHR        ::= "$shr";
APPEND     ::= "+=";
REDUCE     ::= "-=";
AMUL       ::= "*=";
ADIV       ::= "/=";
PLUS       ::= "+";
MINUS      ::= "-";
EQUAL      ::= "==";
NOTEQUAL   ::= "!=";
LESS       ::= "<";
NOTLESS    ::= ">=";
NOTGREATER ::= "<=";
GREATER    ::= ">";
AND        ::= "&&";
OR         ::= "||";
XOR        ::= "^^";
IF         ::= "?";
ELSE       ::= "!";
TRY        ::= "\\";
ALT        ::= "\";
ISNIL      ::= "??";
FNL        ::= "$fnl";

L0_R ::=
	EXPRESSION "]" ^INDEXER_OPERATION;

L0_OP ::=
	L0 L0_R;

ASSIGN_R ::=
	EXPRESSION ^ASSIGN_OPERATION;

L1_OP ::=
	ASSIGN ASSIGN_R;

L1a_O_OP ::=
	APPEND ^OBJECT EXPRESSION ^ADDITION_ASSIGNMENT
	| REDUCE ^OBJECT EXPRESSION ^SUB_ASSIGNMENT
	| AMUL ^OBJECT EXPRESSION ^MUL_ASSIGNMENT
	| ADIV ^OBJECT EXPRESSION ^DIV_ASSIGNMENT;

L2_R ::=
	MESSAGE_PARAMETER { "," MESSAGE_PARAMETER }* ")" ^MESSAGE_OPERATION
	| ")" ^MESSAGE_OPERATION;

L2_OP ::=
	L2 L2_R;

L3_R ::=
	"(" MESSAGE_PARAMETERS? ")" ^ MESSAGE_OPERATION
	| ":" L3_SINGLE_EXPRESSION ^ MESSAGE_OPERATION;

MESSAGE_R ::=
	L3_R
	| eps ^PROPERTY_OPERATION;

RESEND_R ::=
	"(" MESSAGE_PARAMETERS? ")" ^ MESSAGE_OPERATION
	| eps ^PROPERTY_OPERATION;

L3_OP ::=
	L3 MESSAGE MESSAGE_R;

L4_OP ::=
	BAND L4_EXPRESSION ^BAND_OPERATION
	| BOR L4_EXPRESSION ^BOR_OPERATION
	| BXOR L4_EXPRESSION ^BXOR_OPERATION
	| STAR L4_EXPRESSION ^MUL_OPERATION
	| DIV  L4_EXPRESSION ^DIV_OPERATION
	| SHL L4_EXPRESSION ^SHL_OPERATION
	| SHR L4_EXPRESSION ^SHR_OPERATION;

L4_O_OP ::=
	BAND ^OBJECT L4_EXPRESSION ^BAND_OPERATION
	| BOR ^OBJECT L4_EXPRESSION ^BOR_OPERATION
	| BXOR ^OBJECT L4_EXPRESSION ^BXOR_OPERATION
	| STAR ^OBJECT L4_EXPRESSION ^MUL_OPERATION
	| DIV ^OBJECT L4_EXPRESSION ^DIV_OPERATION
	| SHL ^OBJECT L4_EXPRESSION ^SHL_OPERATION
	| SHR ^OBJECT L4_EXPRESSION ^SHR_OPERATION;

L5_OP ::=
	MINUS L5_EXPRESSION ^SUB_OPERATION
	| PLUS L5_EXPRESSION ^ADD_OPERATION;

L5_O_OP ::=
	MINUS ^OBJECT L5_EXPRESSION ^SUB_OPERATION
	| PLUS ^OBJECT L5_EXPRESSION ^ADD_OPERATION;

L6_OP ::=
	EQUAL L6_EXPRESSION ^EQUAL_OPERATION
	| NOTEQUAL L6_EXPRESSION ^NOTEQUAL_OPERATION
	| NOTLESS L6_EXPRESSION ^NOTLESS_OPERATION
	| GREATER L6_EXPRESSION ^GREATER_OPERATION
	| NOTGREATER L6_EXPRESSION ^NOTGREATER_OPERATION
	| LESS L6_EXPRESSION ^LESS_OPERATION;

L6_O_OP ::=
	EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION
	| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION
	| NOTLESS ^OBJECT L6_EXPRESSION ^NOTLESS_OPERATION
	| GREATER ^OBJECT L6_EXPRESSION ^GREATER_OPERATION
	| NOTGREATER ^OBJECT L6_EXPRESSION ^NOTGREATER_OPERATION
	| LESS ^OBJECT L6_EXPRESSION ^LESS_OPERATION;

L6_O_OP_WM ::=
	EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION
	| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION
	| NOTLESS ^OBJECT L6_EXPRESSION ^NOTLESS_OPERATION
	| GREATER ^OBJECT L6_EXPRESSION ^GREATER_OPERATION
	| NOTGREATER ^OBJECT L6_EXPRESSION ^NOTGREATER_OPERATION;

L7_OP ::=
	AND L7_EXPRESSION ^AND_OPERATION
	| OR L7_EXPRESSION ^OR_OPERATION
	| XOR L7_EXPRESSION ^OR_OPERATION;

L7_O_OP ::=
	AND ^OBJECT L7_EXPRESSION ^AND_OPERATION
	| OR ^OBJECT L7_EXPRESSION ^OR_OPERATION
	| XOR ^OBJECT L7_EXPRESSION ^OR_OPERATION;

IF_R ::=
	L8_EXPRESSION { eps ^IF_OPERATION | ":" L8_EXPRESSION ^IF_ELSE_OPERATION };

ELSE_R ::=
	L8_EXPRESSION ^ELSE_OPERATION;

L8_OP ::=
	IF IF_R
	| ELSE ELSE_R;

L8_O_OP ::=
	IF ^OBJECT IF_R
	| ELSE ^OBJECT ELSE_R;

TRY_R ::=
	CATCH { "$fnl" FINALLY }? ^CATCH_OPERATION;

FNL_R ::=
	FINALLY ^FINAL_OPERATION;

ALT_R ::=
	CATCH ^ALT_OPERATION;

CATCH ::=
	MESSAGE MESSAGE_R;

FINALLY ::=
	L7_EXPRESSION;

L9_OP ::= 
	TRY TRY_R
	| ALT ALT_R
	| ISNIL SINGLE_EXPRESSION ^ISNIL_OPERATION;

NESTED_EXPRESSION ::=
	"{" { DECLARATION | META_DECLARATION }* END_OF_BLOCK;

MESSAGE_PARAMETERS ::=
	MESSAGE_PARAMETER { "," MESSAGE_PARAMETER }*;

TEMPLATE_BRACKETS ::=
	"<" TEMPLATE_ARG { "," TEMPLATE_ARG }* ">";

TEMPLATE_ARG ::=
	identifier { TEMPLATE_BRACKETS ^ TEMPLATE_TYPE }?
	| reference
	| global;

PARAMETER ::=
	identifier+ { 
		DYNAMIC_DIMENSION ^ARRAY_TYPE identifier
		| TEMPLATE_BRACKETS identifier
		| eps };

SUB_VARIABLE ::=
	identifier+ { 
		DYNAMIC_DIMENSION ^ARRAY_TYPE identifier
		| TEMPLATE_BRACKETS identifier
		| eps };

MESSAGE ::=
	identifier;

OPERATOR ::=
	"\" ^ ALT_OPERATION | "?" ^ IF_OPERATION | "!" ^ ELSE_OPERATION;

SWITCH_OPTION ::=
	identifier ^ OBJECT SWITCH_CODE
	| { integer | character | string } ^ OBJECT SWITCH_CODE;

SWITCH_LAST_OPTION ::=
	":" SWITCH_CODE;

SWITCH_CODE ::=
	"{" BLOCK;

COLLECTION ::=
	EXPRESSION { "," EXPRESSION }* ;

POSTFIX ::=
	identifier { 
		TEMPLATE_BRACKETS ^ TEMPLATE_TYPE 
 		| "(" MESSAGE_PARAMETER { "," MESSAGE_PARAMETER }* ")" ^ INLINE
		| eps };

DIMENSION ::=
        integer
        | hexinteger
	| identifier;

COMPLEX_NAME ::=
	identifier;

DYNAMIC_DIMENSION ::=
	"[]";

DECLARATION_END ::=
	";";

END_OF_BLOCK ::=
	"}";
