__define eof                 8195;
__define identifier         12292;
__define integer            12293;
__define string             12294;
__define hexinteger         12295;
__define reference          12296;
__defineterminal "}"        12297;
__define character          12298;
__define wide               12300;
__define constant           12301;
__define long               12302;
__define real               12303;

__define DECLARATION         5120;
__define BLOCK               7184;
__define NO_BODY             7185;
__define TEMPLATE_BLOCK      4104;
__define PARAMETER           4106;
__define END_OF_BLOCK        4107;
__define DICTIONARY          4128;
__define META_STATEMENT      4129;
__define INCLUDE_STATEMENT   4130;
__define RELOAD_STATEMENT    4131;
__define OBJECT              4145;
__define TEMPLATE_TYPE       4146;
__define ARRAY_TYPE          4147;
__define NESTED              4224;
__define CLOSURE             4225;
__define MESSAGE             4288;
__define RET_EXPRESSION      7220;
__define GET_EXPRESSION      7222;
__define INIT_EXPRESSION     7223;
__define NESTED_EXPRESSION   6197;
__define INDEXER_OPERATION   6209;
__define ASSIGN_OPERATION    6210;
__define ADDITION_ASSIGNMENT 6211;
__define ADD_OPERATION       6212;
__define SUB_OPERATION       6213;
__define LEN_OPERATION       6214;
__define IF_OPERATION        6215;
__define LESS_OPERATION      6216;
__define NAME_OPERATION      6217;
__define EQUAL_OPERATION     6218;
__define NOT_OPERATION       6219;
__define NOTEQUAL_OPERATION  6220;
__define LOOP_OPERATION      6221;
__define ELSE_OPERATION      6222;
__define IF_ELSE_OPERATION   6223;
__define MUL_OPERATION       6224;
__define DIV_OPERATION       6225;
__define NOTLESS_OPERATION   6226;
__define GREATER_OPERATION   6227;
__define NOTGREATER_OPERATION 6228;
__define EXTERN_OPERATION    6229;
__define NEGATE_OPERATION    6230;
__define VALUE_OPERATION     6231;
__define BAND_OPERATION      6232;
__define BOR_OPERATION       6233;
__define BXOR_OPERATION      6234;
__define BNOT_OPERATION      6235;
__define SHL_OPERATION       6236;
__define SHR_OPERATION       6237;
__define SUB_ASSIGNMENT      6238;
__define MUL_ASSIGNMENT      6239;
__define DIV_ASSIGNMENT      6240;
__define AND_OPERATION       6241;
__define OR_OPERATION        6242;
__define XOR_OPERATION       6243;
__define BREAK_OPERATION     6244;
__define MESSAGE_OPERATION   6337;
__define PROPERTY_OPERATION  6340;
__define EXPRESSION          6288;
__define L5_EXPRESSION       6289;
__define SINGLE_EXPRESSION   6290;
__define L8_EXPRESSION         6291;
__define ROOT_EXPRESSION       6292;
__define L6_EXPRESSION         6293;
__define T_EXPRESSION          6294;
__define L4_EXPRESSION         6295;
__define NT_EXPRESSION         6296;
__define L7_EXPRESSION         6297;
__define L3_SINGLE_EXPRESSION  6298;
__define SWITCH_OPTION 	       6353;
__define SWITCH_LAST_OPTION    6354;
__define SWITCH_CODE 	       6355;
__define COLLECTION_EXPRESSION 6356;
__define POSTFIX               4200;
__define TEMPLATE_POSTFIX      4201;
__define TEMPLATE_ARG          4208;
__define DIMENSION             5233;
__define RESEND                7366;
__define CATCH_OPERATION       7367;
__define CATCH                 7368;
__define REDIRECT              7371;
__define ALT_OPERATION         7372;
__define ISNIL_OPERATION       7373;
__define SWITCH_OPERATION      7376;
__define COMPLEX_NAME 	       4302;
__define INLINE                4303;

START ::= 
	{ DECLARATION | META_DECLARATION }+ eof
	| eof;

META_DECLARATION ::=
	"#new" DICTIONARY DECLARATION_END
	| "#let" META_STATEMENT DECLARATION_END
	| "#include" INCLUDE_STATEMENT  DECLARATION_END
	| "#reload" RELOAD_STATEMENT DECLARATION_END;	

DECLARATION ::=
	{ identifier | reference }+ IR_DECLARATION;

IR_DECLARATION ::=
	{ TEMPLATE_BRACKETS identifier? | DYNAMIC_DIMENSION ^ARRAY_TYPE identifier } { POSTFIXES NESTED_SCOPE | SCOPE }
	| "::" COMPLEX_NAME TEMPLATE_BRACKETS? METHOD_SCOPE
	| POSTFIXES NESTED_SCOPE
	| SCOPE;

DICTIONARY ::=
	identifier+;

META_STATEMENT ::=
	EXPRESSION;

RELOAD_STATEMENT ::=
	identifier;

INCLUDE_STATEMENT ::=
	{ identifier | reference }+ ^ OBJECT;

NESTED_SCOPE ::=
	"{" { DECLARATION | META_DECLARATION }* END_OF_BLOCK
	| "=" GET_EXPRESSION DECLARATION_END
	| DECLARATION_END;

SCOPE ::=
        "=" GET_EXPRESSION DECLARATION_END
	| ":=" INIT_EXPRESSION DECLARATION_END
	| "{" { DECLARATION | META_DECLARATION }* END_OF_BLOCK
	| "[" DIMENSION "]" DECLARATION_END
	| METHOD_SCOPE
        | DECLARATION_END;

METHOD_SCOPE ::=
	"(" { PARAMETER { "," PARAMETER }* }? ")" POSTFIXES? METHOD_BODY;

POSTFIXES ::=
	":" POSTFIX { "," POSTFIX }*;

METHOD_BODY ::=
	"{" BLOCK
	| "=" RET_EXPRESSION DECLARATION_END
	| "<=" RESEND { DECLARATION_END | "{" BLOCK }
	| "=>" REDIRECT DECLARATION_END
	| NO_BODY;

NO_BODY ::=
	";";

BLOCK ::=
	STATEMENT NEXT_STATEMENT
	| "^" RET_EXPRESSION LAST_STATEMENT 
	| END_OF_BLOCK;

LAST_STATEMENT ::=
	DECLARATION_END END_OF_BLOCK
	| END_OF_BLOCK;

NEXT_STATEMENT ::=
	DECLARATION_END { 
		STATEMENT NEXT_STATEMENT 
		| "^" RET_EXPRESSION LAST_STATEMENT 
		| END_OF_BLOCK }
	| END_OF_BLOCK;

STATEMENT ::=
	ROOT_EXPRESSION
	| "#include" INCLUDE_STATEMENT
	| "#let" META_STATEMENT
	| "#new" DICTIONARY;

RESEND ::=
	identifier+ RESEND_R;

REDIRECT ::= 
	EXPRESSION;

RET_EXPRESSION ::=
	EXPRESSION;

INIT_EXPRESSION ::=
	EXPRESSION;

GET_EXPRESSION ::=
	EXPRESSION;

T_EXPRESSION ::=
	"{" BLOCK;

NT_EXPRESSION ::=
	"{" BLOCK
	| "(" identifier+ ")" { 
		"{" ^ PARAMETER BLOCK ^CLOSURE
		| eps ^OBJECT ^EXPRESSION };

ROOT_EXPRESSION ::=
        identifier {
		L1a_O_OP
		| L0 ^OBJECT L0_R { 
			L1_OP 
			| L3_OP 
			| eps }
		| ASSIGN ^OBJECT ASSIGN_R
		| L2 ^OBJECT MESSAGE_PARAMETERS? ")" {
			T_EXPRESSION { identifier NT_EXPRESSION }? ^ TEMPLATE_BLOCK
			| eps ^ MESSAGE_OPERATION }
		| L3 ^OBJECT MESSAGE { 
			L3_R L3_OP*
			| ASSIGN EXPRESSION ^PROPERTY_OPERATION 
			| eps ^PROPERTY_OPERATION }
		| NOTLESS ^OBJECT L6_EXPRESSION ^NOTLESS_OPERATION
		| LESS ^OBJECT L6_EXPRESSION { 
			">" ^TEMPLATE_TYPE identifier ^OBJECT { 
				ASSIGN ASSIGN_R 
				| eps }
			| eps ^LESS_OPERATION }
		| "=>" ^OBJECT { SWITCH_OPTION+ SWITCH_LAST_OPTION? } ^SWITCH_OPERATION
		| identifier+ {
			L0 ^OBJECT L0_R L1_OP?
			| ASSIGN ^OBJECT ASSIGN_R
			| L2 ^OBJECT L2_R L3_OP? L8_OP?
			| DYNAMIC_DIMENSION ^ARRAY_TYPE {
				identifier ^OBJECT ASSIGN ASSIGN_R
				| L2 ^OBJECT L2_R
				| "{" ^OBJECT COLLECTION "}" ^ COLLECTION_EXPRESSION L3_OP* }
			| L3 ^OBJECT MESSAGE {
				L3_R L3_OP*
				| ASSIGN EXPRESSION ^PROPERTY_OPERATION 
				| eps ^PROPERTY_OPERATION }
			| L4_O_OP
                        | L5_O_OP
			| EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION
			| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION
			| LESS ^OBJECT L6_EXPRESSION { 
				">" ^TEMPLATE_TYPE identifier ^OBJECT { 
					ASSIGN ASSIGN_R 
					| eps }
				| eps ^LESS_OPERATION }
			| TRY ^OBJECT TRY_R
			| ISNIL ^OBJECT SINGLE_EXPRESSION ^ISNIL_OPERATION
			| eps ^OBJECT
		}		
		| TRY ^OBJECT TRY_R
		| T_EXPRESSION { identifier NT_EXPRESSION }? ^ TEMPLATE_BLOCK
		| eps ^OBJECT
	}
	| reference {
		L0 ^OBJECT L0_R L1_OP
		| ASSIGN ^OBJECT ASSIGN_R
		| L2 ^OBJECT L2_R L3_OP? L8_OP?
		| L3 ^OBJECT MESSAGE MESSAGE_R L6_OP?
		| L4_O_OP
                | L5_O_OP
		| EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION
		| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION
		| TRY ^OBJECT TRY_R
		| ISNIL ^OBJECT SINGLE_EXPRESSION ^ISNIL_OPERATION
		| eps ^OBJECT
	}
	| { string | integer | hexinteger | wide } { 
		L0 ^OBJECT L0_R 
		| L3 ^OBJECT MESSAGE MESSAGE_R
		| L4_O_OP
                | L5_O_OP
		| EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION
		| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION
		| TRY ^OBJECT TRY_R
		| ISNIL ^OBJECT SINGLE_EXPRESSION ^ISNIL_OPERATION
		| eps ^OBJECT }
	| "(" SUB_EXPRESSION L8_OP?
	| "!" SINGLE_EXPRESSION ^NOT_OPERATION
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION
	| "$rep" EXPRESSION ^LOOP_OPERATION
	| "$ext" EXPRESSION ^EXTERN_OPERATION
	| "$break" ^BREAK_OPERATION;

EXPRESSION ::=
	{ identifier | reference }+ { 
		L0 ^OBJECT L0_R { L1_OP | L3_OP | eps }
		| DYNAMIC_DIMENSION ^ARRAY_TYPE { 
			"{" ^OBJECT COLLECTION "}" ^ COLLECTION_EXPRESSION
			| L2 ^OBJECT L2_R }
		| ASSIGN ^OBJECT ASSIGN_R
		| L1a_O_OP
		| L2 ^OBJECT L2_R L3_OP* L5_OP* { L8_OP | L9_OP }?
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP* L4_OP* L5_OP* L6_OP?
		| L4_O_OP L4_OP* L6_OP?
		| SHL ^OBJECT L4_EXPRESSION ^SHL_OPERATION
		| SHR ^OBJECT L4_EXPRESSION ^SHR_OPERATION
                | L5_O_OP L6_OP?
		| L6_O_OP_WM L7_OP?
		| LESS ^OBJECT L6_EXPRESSION { 
			">" ^TEMPLATE_TYPE { 
				NESTED_EXPRESSION ^NESTED
				| identifier ^OBJECT 
				| L0 ^OBJECT L0_R
				| L2 ^OBJECT L2_R L3_OP*
				| L3 ^OBJECT MESSAGE MESSAGE_R 
				| eps }
			| AND ^LESS_OPERATION L7_EXPRESSION ^AND_OPERATION
			| OR ^LESS_OPERATION L7_EXPRESSION ^OR_OPERATION
			| eps ^LESS_OPERATION }
		| TRY ^OBJECT TRY_R
		| ISNIL ^OBJECT SINGLE_EXPRESSION ^ISNIL_OPERATION
		| NESTED_EXPRESSION ^NESTED L3_OP*
		| eps ^OBJECT }
	| { string | integer | hexinteger | long | real | character | wide } { 
		L0 ^OBJECT L0_R 
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP* L6_OP?
		| L4_O_OP
                | L5_O_OP L6_OP?
		| EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION
		| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION
		| TRY ^OBJECT TRY_R
		| ISNIL ^OBJECT SINGLE_EXPRESSION ^ISNIL_OPERATION
		| eps ^OBJECT }
	| "(" SUB_EXPRESSION L2_OP? L3_OP* L8_OP?
	| "$name" SINGLE_EXPRESSION ^NAME_OPERATION
	| "$len" SINGLE_EXPRESSION ^LEN_OPERATION
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION
	| "!" SINGLE_EXPRESSION ^NOT_OPERATION
	| "~" SINGLE_EXPRESSION ^BNOT_OPERATION
	| "-" SINGLE_EXPRESSION ^NEGATE_OPERATION;

SUB_EXPRESSION ::=
	identifier+ {
	        "=>" ^ PARAMETER RET_EXPRESSION ^CLOSURE ")" ^EXPRESSION
		| "," PARAMETER { "," PARAMETER }* 
			"=>" RET_EXPRESSION ^CLOSURE ")" ^EXPRESSION
		| L2 ^OBJECT L2_R ")" ^EXPRESSION
		| EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION ")"
		| ")" {
			"{" ^ PARAMETER BLOCK ^CLOSURE ^EXPRESSION
			| eps ^OBJECT ^EXPRESSION
		}
	}
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION ")" ^EXPRESSION;

SUB_SINGLE_EXPRESSION ::=
	identifier { 
		L2 ^OBJECT L2_R L3_OP? ")"
		| L3 ^OBJECT MESSAGE MESSAGE_R L6_OP? ")"
		| L4_O_OP ")"
                | L5_O_OP ")"
		| EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION ")"
		| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION ")"
		| ")" ^OBJECT };

SINGLE_EXPRESSION ::=
	{ identifier | integer | string } ^OBJECT
	| "(" SUB_SINGLE_EXPRESSION;

L4_EXPRESSION ::=
	identifier ^OBJECT
	| { integer | hexinteger | real | long } ^OBJECT;

L5_EXPRESSION ::=
	identifier { 
		L0 ^OBJECT L0_R
		| L2 ^OBJECT L2_R L3_OP*
		| L3 ^OBJECT MESSAGE MESSAGE_R L3_OP*
		| L4_O_OP
		| eps ^OBJECT }
	| { integer | hexinteger | string | wide | long } { 
		L4_O_OP
		| eps ^OBJECT }
	| "(" SUB_EXPRESSION;

L3_SINGLE_EXPRESSION ::=
	{ identifier | integer | string } ^OBJECT
	| "(" SUB_L3_SINGLE_EXPRESSION;

SUB_L3_SINGLE_EXPRESSION ::=
	identifier { 
		L2 ^OBJECT L2_R L3_OP? ")"
		| L3 ^OBJECT MESSAGE MESSAGE_R L6_OP? ")"
		| L4_O_OP ")"
                | L5_O_OP ")"
		| EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION ")"
		| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION ")"
		| ")" {
			"{" ^ PARAMETER BLOCK ^CLOSURE
			| eps ^OBJECT
		}
	};

L6_EXPRESSION ::=
	identifier+ { 
		L0 ^OBJECT L0_R
		| L2 ^OBJECT L2_R
		| L3 ^OBJECT MESSAGE MESSAGE_R
		| eps ^OBJECT }
	| { integer | hexinteger | real | long | string } ^OBJECT
	| "*" SINGLE_EXPRESSION ^VALUE_OPERATION;

L7_EXPRESSION ::=
	identifier { 
		NOTGREATER ^OBJECT L6_EXPRESSION ^NOTGREATER_OPERATION
		| NOTLESS ^OBJECT L6_EXPRESSION ^NOTLESS_OPERATION
		| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION
		| LESS ^OBJECT L6_EXPRESSION ^LESS_OPERATION
		| eps ^OBJECT }
	| { integer | hexinteger } ^OBJECT;

L8_EXPRESSION ::=
	"{" BLOCK ^ CLOSURE
	| SINGLE_EXPRESSION;

MESSAGE_PARAMETER ::=
	EXPRESSION;

L0         ::= "[";
ASSIGN     ::= ":=";
L2         ::= "(";
L3         ::= ".";
BAND       ::= "&";
BOR        ::= "|";
BXOR       ::= "^";
STAR       ::= "*";
DIV        ::= "/";
SHL        ::= "$shl";
SHR        ::= "$shr";
APPEND     ::= "+=";
REDUCE     ::= "-=";
AMUL       ::= "*=";
ADIV       ::= "/=";
PLUS       ::= "+";
MINUS      ::= "-";
EQUAL      ::= "==";
NOTEQUAL   ::= "!=";
LESS       ::= "<";
NOTLESS    ::= ">=";
NOTGREATER ::= "<=";
GREATER    ::= ">";
AND        ::= "&&";
OR         ::= "||";
IF         ::= "?";
ELSE       ::= "!";
TRY        ::= "\\";
ISNIL      ::= "??";

L0_R ::=
	EXPRESSION "]" ^INDEXER_OPERATION;

L0_OP ::=
	L0 L0_R;

ASSIGN_R ::=
	EXPRESSION ^ASSIGN_OPERATION;

L1_OP ::=
	ASSIGN ASSIGN_R;

L1a_O_OP ::=
	APPEND ^OBJECT EXPRESSION ^ADDITION_ASSIGNMENT
	| REDUCE ^OBJECT EXPRESSION ^SUB_ASSIGNMENT
	| AMUL ^OBJECT EXPRESSION ^MUL_ASSIGNMENT
	| ADIV ^OBJECT EXPRESSION ^DIV_ASSIGNMENT;

L2_R ::=
	MESSAGE_PARAMETER { "," MESSAGE_PARAMETER }* ")" ^MESSAGE_OPERATION
	| ")" ^MESSAGE_OPERATION;

L2_OP ::=
	L2 L2_R;

L3_R ::=
	"(" MESSAGE_PARAMETERS? ")" ^ MESSAGE_OPERATION
	| ":" L3_SINGLE_EXPRESSION ^ MESSAGE_OPERATION;

MESSAGE_R ::=
	L3_R
	| eps ^PROPERTY_OPERATION;

RESEND_R ::=
	"(" MESSAGE_PARAMETERS? ")" ^ MESSAGE_OPERATION
	| eps ^PROPERTY_OPERATION;

L3_OP ::=
	L3 MESSAGE MESSAGE_R;

L4_OP ::=
	BAND L4_EXPRESSION ^BAND_OPERATION
	| BOR L4_EXPRESSION ^BOR_OPERATION
	| STAR L4_EXPRESSION ^MUL_OPERATION
	| DIV  L4_EXPRESSION ^DIV_OPERATION;

L4_O_OP ::=
	BAND ^OBJECT L4_EXPRESSION ^BAND_OPERATION
	| BOR ^OBJECT L4_EXPRESSION ^BOR_OPERATION
	| BXOR ^OBJECT L4_EXPRESSION ^BXOR_OPERATION
	| STAR ^OBJECT L4_EXPRESSION ^MUL_OPERATION
	| DIV ^OBJECT L4_EXPRESSION ^DIV_OPERATION;

L5_OP ::=
	MINUS L5_EXPRESSION ^SUB_OPERATION
	| PLUS L5_EXPRESSION ^ADD_OPERATION;

L5_O_OP ::=
	MINUS ^OBJECT L5_EXPRESSION ^SUB_OPERATION
	| PLUS ^OBJECT L5_EXPRESSION ^ADD_OPERATION;

L6_OP ::=
	EQUAL L6_EXPRESSION ^EQUAL_OPERATION
	| NOTEQUAL L6_EXPRESSION ^NOTEQUAL_OPERATION
	| NOTLESS L6_EXPRESSION ^NOTLESS_OPERATION
	| GREATER L6_EXPRESSION ^GREATER_OPERATION
	| NOTGREATER L6_EXPRESSION ^NOTGREATER_OPERATION
	| LESS L6_EXPRESSION ^LESS_OPERATION;

L6_O_OP_WM ::=
	EQUAL ^OBJECT L6_EXPRESSION ^EQUAL_OPERATION
	| NOTEQUAL ^OBJECT L6_EXPRESSION ^NOTEQUAL_OPERATION
	| NOTLESS ^OBJECT L6_EXPRESSION ^NOTLESS_OPERATION
	| GREATER ^OBJECT L6_EXPRESSION ^GREATER_OPERATION
	| NOTGREATER ^OBJECT L6_EXPRESSION ^NOTGREATER_OPERATION;

L7_OP ::=
	AND L7_EXPRESSION ^AND_OPERATION
	| OR L7_EXPRESSION ^OR_OPERATION;

IF_R ::=
	L8_EXPRESSION { eps ^IF_OPERATION | ":" L8_EXPRESSION ^IF_ELSE_OPERATION };

ELSE_R ::=
	L8_EXPRESSION ^ELSE_OPERATION;

L8_OP ::=
	IF IF_R
	| ELSE ELSE_R;

TRY_R ::=
	CATCH ^CATCH_OPERATION;

CATCH ::=
	MESSAGE MESSAGE_R;

L9_OP ::= 
	TRY TRY_R
	| ISNIL SINGLE_EXPRESSION ^ISNIL_OPERATION;

NESTED_EXPRESSION ::=
	"{" { DECLARATION | META_DECLARATION }* END_OF_BLOCK;

MESSAGE_PARAMETERS ::=
	MESSAGE_PARAMETER { "," MESSAGE_PARAMETER }*;

TEMPLATE_BRACKETS ::=
	"<" TEMPLATE_ARG { "," TEMPLATE_ARG }* ">";

TEMPLATE_ARG ::=
	identifier
	| reference;

PARAMETER ::=
	identifier+ { 
		DYNAMIC_DIMENSION ^ARRAY_TYPE identifier
		| TEMPLATE_BRACKETS identifier
		| eps };

MESSAGE ::=
	identifier;

SWITCH_OPTION ::=
	identifier ^ OBJECT SWITCH_CODE
	| integer ^ OBJECT SWITCH_CODE;

SWITCH_LAST_OPTION ::=
	":" SWITCH_CODE;

SWITCH_CODE ::=
	"{" BLOCK;

COLLECTION ::=
	EXPRESSION { "," EXPRESSION }+ ;

POSTFIX ::=
	identifier { 
		TEMPLATE_BRACKETS ^ TEMPLATE_TYPE 
 		| "(" MESSAGE_PARAMETER { "," MESSAGE_PARAMETER }* ")" ^ INLINE
		| eps };

DIMENSION ::=
        integer
        | hexinteger;	

COMPLEX_NAME ::=
	identifier;

DYNAMIC_DIMENSION ::=
	"[]";

DECLARATION_END ::=
	";";

END_OF_BLOCK ::=
	"}";
