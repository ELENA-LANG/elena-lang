//        ELENA Language 5.10
//      inline system library

// built-in constants

define EXCEPTION_ACCESS_VIOLATION  101h
define ELENA_ERR_DIVIDE_BY_ZERO    102h
define ELENA_ERR_OUT_OF_MEMORY     103h

// prop_mssg_mask - property message mask

define ARG_MASK              0000001Fh
define SPECIAL_MESSAGE       00000020h
define VARIADIC_MESSAGE      00000080h
define SPECIAL_MESSAGE_INV  0FFFFFFDFh

// ; NOTE : __ indicates platform dependant constant!!
define __rsrv_object_offset32        12      
define __rsrv_object_offset64        20
define __page_size32                 16
define __page_size64                 32

define __temp_index32                1      
define __temp_index64                1      

// ; external methods

procedure __object."#dispatch[1]"

  bsredirect  

  open
  reserve  __page_size
  pushf    -__rsrv_object_offset
  pusha
  pushf    -__rsrv_object_offset
  movr     class : system'Message
  callextr api : tempObject, 1 
  movr     class : system'MethodNotFoundException
  storesi  0
  pushr    mssgconst : "new[3]"

  throw

end

procedure __object.equal[2]

  peeksi 1
  pushsi 2
  equal
  select const : false, const : true
  pop
  quit
  
end

procedure __object."equalReference$system@Object$system@Object[2]"

  peeksi 1
  pushsi 2
  equal
  select const : false, const : true
  pop
  quit
  
end

procedure __object."__getClass$system@Object[1]"

  peeksi 1
  class
  quit

end

procedure __object."raise[1]"

  pop
  peeksi 0
  throw
  
end

procedure __dptr."system$setReference[2]"

  loadsi 2
  save
  quit

end

procedure __literal."equal$system@String[2]"

  pushsi 2
  pushsi 2
  callextr api : sequal, 2
  freei 2
  select const : false, const : true
  quit
  
end

procedure __literal."less$system@String[2]"

  pushsi 2
  pushsi 2
  callextr api : sless, 2
  freei 2
  select const : false, const : true
  quit
  
end

procedure __literal."readLengthTo$system@String$@system@ref#1&system@IntNumber[2]"

  peeksi 1
  len
  dec 1
  peeksi 2
  save
  quit

end


procedure __literal."save$system@IntNumber$@system@Array#1&system@CharValue$@system@ref#1&system@IntNumber[4]"

  pushsi 4
  pushsi 4
  pushsi 4
  pushsi 4

  callextr api : strtochararray, 4
  
  freei  4
  quit

end

procedure __wide."equal$system@WideString[2]"

  pushsi 2
  pushsi 2
  callextr api : wequal, 2
  freei 2
  select const : false, const : true
  quit
  
end

procedure __wide."less$system@WideString[2]"

  pushsi 2
  pushsi 2
  callextr api : wless, 2
  freei 2
  select const : false, const : true
  quit
  
end

procedure __wide."readLengthTo$system@WideString$@system@ref#1&system@IntNumber[2]"

  peeksi 1
  len
  shr 1
  dec 1
  peeksi 2
  save
  quit

end

procedure __char."readLengthTo$system@CharValue$@system@ref#1&system@IntNumber[2]"

  peeksi 1
  load
  // ; < 80 - 1
  lessn labEnd, 80h
  // ; <= 800 - 2
  lessn labEnd2, 800h 
  lessn labEnd3, 10000h 
  movn 4
  peeksi 2
  save  
  quit
labEnd:
  movn 1
  peeksi 2
  save  
  quit
labEnd2:
  movn 2
  peeksi 2
  save  
  quit
labEnd3:
  movn 3
  peeksi 2
  save  
  quit

end

procedure __char."readWideLengthTo$system@CharValue$@system@ref#1&system@IntNumber[2]"

  peeksi 1
  load
  and    0FFFFh
  // ; < 80 - 1
  lessn  labEnd, 0D800h
  movn   2
  peeksi 2
  save  
  quit
labEnd:
  movn   4
  peeksi 2
  save  
  quit

end

procedure __array."readLengthTo$system@Array$@system@ref#1&system@IntNumber[2]"

  peeksi 1
  count
  peeksi 2
  save
  quit

end

procedure __exception."on[2]"

  open 
  hook    labNotFound
  alloci  1
  storesi 0 
  peekfi  -2
  movm    mssgconst : "#invoke[1]"

  callvi  0

labReturn:

  unhook

  close
  quit

labNotFound:

  restore __page_size

  close
  pushsi  __temp_index

labContinueError:

  popa
  unhook
  pusha
  throw

end

procedure __message."#dispatch[1]"

  pushd

  // check if it is invoke
  and     SPECIAL_MESSAGE
  ifn     labDefault, 0 

  load
  storev

  elsed   labDefault

  popd
  peeksi  1
  jumpvi  0

labDefault:
  popd
  bsredirect 

  open
  reserve  __page_size
  pushf    -__rsrv_object_offset
  pusha
  pushf    -__rsrv_object_offset
  movr     class : system'Message
  callextr api : tempObject, 1 
  movr     class : system'MethodNotFoundException
  storesi  0
  pushr    mssgconst : "new[3]"

  throw
  
end

procedure __event."#dispatch[1]"

  bsredirect  

  open
  reserve  8

  savef    -8
  xsavef   -4, 0

  geti     0  // ; get the first field !! better to define a special array (like castover group object)
  pusha

  // ; define the message length
  loadf    -8
  and      ARG_MASK
  ifn      labSkip, 0
  
  allocd

  // ; copy message
  movsip  0 
  pushfip -1

labNextParam:
  dec      1
  xtrans
  elsen    labNextParam, 0

labSkip:
  pop

  peekfi   1

labNext:
  count
  movf     -4
  if       labEnd

  peekfi   1
  loadf    -4
  get
  inc      1
  savef    -4
  
  loadf    -8
  callvi   0
  
  peekfi   1
  jump     labNext

labEnd:
  loadfi  -1
  restore  8
  close
  quit

end

procedure __exception.register[0]

  movr intern : system'core_routines'critical_exception_handler
  callextr api : register_critical_exception_handler, 0

  quit

end

procedure __chararray."write$@system@Array#1&system@CharValue$system@IntNumber$system@IntNumber$@system@Array#1&system@CharValue[4]"

  pushsi 4
  pushsi 4
  pushsi 4
  pushsi 4
  
  callextr api : ninsert, 4
  ifn labErr, 0 

  peeksi 0
  freei  4
  quit

labErr:
  open
  pushr class : system'InvalidArgumentException
  pushr mssgconst : "new[1]"
  throw  

end

procedure __literalconvertor."convert$system@CharValue$@system@Array#1&system@ByteNumber$@system@ref#1&system@IntNumber[3]"

  peeksi 1                                                       
  load
  ifn    labEmpty, 0

  pushsi 2
  pushsi 2
  callextr api : chartostr, 2
  freei  2

  peeksi 3
  save
  quit
  
labEmpty:
  movn 0
  peeksi 3
  save
  quit

end

procedure __wideconvertor."convert$system@String$@system@Array#1&system@ShortNumber$@system@ref#1&system@IntNumber[3]"

  pushsi 1
  pushsi 3
  callextr api : strtowstr, 2
  freei 2
  peeksi 3
  save
  quit

end

procedure __wideconvertor."convert$system@CharValue$@system@Array#1&system@ShortNumber$@system@ref#1&system@IntNumber[3]"

  peeksi 1
  load
  ifn    labEmpty, 0

  pushsi 2
  pushsi 2
  callextr api : chartowstr, 2
  freei  2
  peeksi 3
  save
  quit

labEmpty:
  movn 0
  peeksi 3
  save
  quit

end

procedure __byteconvertor."convert$system@ShortNumber$@system@ref#1&system@ByteNumber[2]"

  peeksi 1
  load

  lessn labErr, 0  
  lessn labCopy, 0FFh

labErr:  
  pushr class : system'OutOfRangeException
  pushr mssgconst : "new[1]"
  throw    

labCopy:
  peeksi 2
  save
  quit  

end

procedure __shortconvertor."convert$system@ByteNumber$@system@ref#1&system@ShortNumber[2]"

  peeksi 1
  load
  peeksi 2
  save
  quit  

end

procedure __longconvertor."convert$system@IntNumber$@system@ref#1&system@LongNumber[2]"
  
  peeksi 1
  load
  peeksi 2
  lload
  quit

end

procedure __longconvertor."convert$system@String$system@IntNumber$@system@ref#1&system@LongNumber[3]"

  pushn  0
  pushsi 4
  pushsi 4
  pushsi 4  
  callextr api : strtolong, 3
  freei 4

  ifr      labErr, 0
  quit

labErr:
  open
  pushr class : system'FormatException
  pushr mssgconst : "new[1]"
  throw

end

procedure __longconvertor."convert$system@RealNumber$@system@ref#1&system@LongNumber[2]"

  peeksi 1
  rload
  peeksi 2
  rsavel
  quit

end

procedure __intconvertor."convert$system@LongNumber$@system@ref#1&system@IntNumber[2]"

  peeksi   1
  pusha
  callextr api : longtoint, 1
  pop

  ifr      labErr, 0
  peeksi   2
  save
  quit  

labErr:
  pushr class : system'OutOfRangeException
  pushr mssgconst : "new[1]"
  throw    

end

procedure __intconvertor."convert$system@String$system@IntNumber$@system@ref#1&system@IntNumber[3]"

  pushsi 2
  pushsi 2  
  callextr api : strtoint, 2
  freei 2

  ifr      labErr, 0
  peeksi 3
  save
  quit

labErr:
  open
  pushr class : system'FormatException
  pushr mssgconst : "new[1]"
  throw

end

procedure __intconvertor."convert$system@RealNumber$@system@ref#1&system@IntNumber[2]"

  peeksi 1
  rload
  peeksi 2  
  rsaven
  peeksi 1
  quit

end

procedure __realconvertor."convert$system@String$system@IntNumber$@system@ref#1&system@RealNumber[3]"
  
  pushn    0
  pushsi   4
  pushsi   4
  pushsi   4  
  callextr api : strtoreal, 3
  freei    4
  ifr      labErr, 0
  quit

labErr:
  open
  pushr class : system'FormatException
  pushr mssgconst : "new[1]"
  throw

end

procedure __realconvertor."convert$system@IntNumber$@system@ref#1&system@RealNumber[2]"
  
  peeksi 1
  load
  rset
  peeksi 2
  rsave
  quit

end

procedure __realconvertor."convert$system@LongNumber$@system@ref#1&system@RealNumber[2]"
  
  pushsi 2
  pushsi 2  
  callextr api : longtoreal, 2
  freei 2
  quit

end

// ; system routines

symbol sta_start

  open
  reserve  sizeof ProgramHeader

  alloci   5

  movfip   -1
  storesi  0
  callextr extern : PrepareEM, 0201h

  movf     -4
  storesi  0
  callextr api : initProcess, 1

  movf     -4
  storesi  4
  movr     entry : "$forwards'$program"
  storesi  3
  movr     api : veh_handler
  storesi  2
  movr     api : default_handler
  storesi  1
  loadenv
  savesi   0
  callextr extern : InitializeSTA, 0205h

  restore  sizeof ProgramHeader
  close
  quit

end

procedure critical_exception_handler

  open
  ifn   labAccessViolation, EXCEPTION_ACCESS_VIOLATION
  ifn   labDivisionByZero, ELENA_ERR_DIVIDE_BY_ZERO
  ifn   labOutOfMemory, ELENA_ERR_OUT_OF_MEMORY

  pushr class : system'CriticalException
  pushr mssgconst : "new[1]"
  throw

labAccessViolation:
  pushr class : system'NilReferenceException
  pushr mssgconst : "new[1]"
  throw

labDivisionByZero:
  pushr class : system'DivisionByZeroException
  pushr mssgconst : "new[1]"
  throw

labOutOfMemory:
  pushr class : system'OutOfMemoryException
  pushr mssgconst : "new[1]"
  throw

end
