//        ELENA Language 6.0
//      inline system library

define EXCEPTION_ACCESS_VIOLATION  101h;
define ELENA_ERR_DIVIDE_BY_ZERO    102h;
define ELENA_ERR_OUT_OF_MEMORY     103h;

define FUNCTION_MESSAGE       00000020h;

define ex_struct_size32              16; 
define ex_struct_size64              32; 

define page_size32                   16;
define page_size64                   32;

define ptr_size32                     4;
define ptr_size64                     8;


define __realSize                     8;

define err_ret          -1;

procedure __object_dispatcher

  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  set        class : "system'MethodNotFoundException"
  store      sp:0

  set        mssgconst : "new[3]"
  throw

end

procedure __object_equal

  peek        sp:0
  cmp         sp:1
  seleq       class:"system'BoolValue#true", class:"system'BoolValue#false"

end

procedure __object_class

  peek        sp:0
  class

end

procedure __object_instanceOf

  peek        sp:0
  class
  cmp         sp:1
  seleq       class:"system'BoolValue#true", class:"system'BoolValue#false"

end

procedure __exception_handler

  xflush          sp:0
  xflush          sp:1
  open            :3, :0 
  store           fp:1 

  tst             mssg:"function:#try_invoke[2]"
  jne             Lab01

  set             mssgconst:"fallback[2]"
  store           sp:1 
  peek            fp:1 
  store           sp:0 
  peek            fp:-2 
  mov             mssg:"function:#try_invoke[2]" 
  call            vt:0 

  jump            Lab00

Lab01:
  peek            fp:1 
  store           sp:0 
  peek            fp:-2 
  mov             mssg:"function:#invoke[1]" 
  call            vt:0 

Lab00:
  peek            fp:1 
  close           :0 
  quit             

end

procedure __lazy_dispatcher

  xflush     sp:0
  xflush     sp:1

  open       (2)[],[tmp]
  save       dp:tmp
  vcall      mssg:"function:#invoke[0]", class:"system'BaseLazyExpression"
  load       dp:tmp  
  close      []

  xrefresh   sp:0
  xrefresh   sp:1

  jump       vt:0

end

procedure __exception_raise

  xflush     sp:0
  xflush     sp:1

  open       (2),[]
  throw
  close      []

end

procedure __message_dispatcher

  tstn        FUNCTION_MESSAGE
  jeq         labDefault

  loadv
  xcmp
  jne         labDefault

  peek        sp:0
  jump        vt:0

labDefault:

  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  set        class : "system'MethodNotFoundException"
  store      sp:0

  set        mssgconst : "new[3]"
  throw

end

procedure __ext_message_dispatcher

  tstn        FUNCTION_MESSAGE
  jeq         labDefault

  loadv
  xcmp
  jne         labDefault

  get         i:1
  xjump

labDefault:

  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  set        class : "system'MethodNotFoundException"
  store      sp:0

  set        mssgconst : "new[3]"
  throw

end

procedure __str_equal (s1, s2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[s_len,index,ch,ch2]

  peek       fp:s1
  nlen       1
  save       dp:s_len

  peek       fp:s2
  nlen       1
  set        dp:s_len
  xcmp
  jne        labNotEqual

  sub        n:1

  nsave      dp:index, 0

  peek       fp:s1
  store      sp:0
  peek       fp:s2
  store      sp:1

labCheck:
  load       dp:index
  xcmp       dp:s_len
  jeq        labLoopEnd

  nsave      dp:ch, 0
  nsave      dp:ch2, 0

  set        dp:ch
  read       1

  xswap      sp:1

  set        dp:ch2
  read       1

  load
  xcmp       dp:ch 
  jne        labNotEqual

  nadd       dp:index, 1
  xswap      sp:1
  jump       labCheck

labLoopEnd:
  set        class:"system'BoolValue#true"
  jump       labEnd

labNotEqual:
   set       class:"system'BoolValue#false"

labEnd:
  close      []

end

procedure __str_less (s1, s2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[s_len,index,ch,ch2]

  peek       fp:s1
  nlen       1
  sub        n:1
  save       dp:s_len

  peek       fp:s2
  nlen       1
  sub        n:1
  set        dp:s_len
  xcmp
  jne        labNotLess

  nsave      dp:index, 0

  peek       fp:s1
  store      sp:0
  peek       fp:s2
  store      sp:1

labCheck:
  load       dp:index
  xcmp       dp:s_len
  jeq        labLoopEnd

  nsave      dp:ch, 0
  nsave      dp:ch2, 0

  set        dp:ch
  read       1

  xswap      sp:1

  set        dp:ch2
  read       1

  xswap      sp:1
  load
  xcmp       dp:ch
  jlt        labNotLess

  nadd       dp:index, 1
  jump       labCheck

labLoopEnd:
  set        dp:ch2
  load
  xcmp       dp:ch
  jeq        labNotLess

  set        class:"system'BoolValue#true"
  jump       labEnd

labNotLess:
   set       class:"system'BoolValue#false"

labEnd:
  close      []

end

procedure __str_copysubs (self, s1, s2, index, len)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp]

  peek       fp:index
  store      sp:0
  copy       dp:i1, 4
  nsave      dp:i2, 0

  peek       fp:s1
  store      sp:1

  peek       fp:s2
  store      sp:0

  peek       fp:len
  load       
  cmp        n:0
  jeq        labEnd

labNext:
  set        dp:tmp
  load       dp:i2
  read       1
  add        n:1
  save       dp:i2

  xswap      sp:1
  load       dp:i1
  write      1
  add        n:1
  save       dp:i1
  xswap      sp:1

  peek       fp:len
  load       
  xcmp       dp:i2
  jne        labNext

labEnd:
  nsave      dp:tmp, 0

  xswap      sp:1
  set        dp:tmp
  load       dp:i1
  write      1

  close      []

end

procedure __str_xcopysubs (self, s1, s2, index1, len, index2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp,cnt]

  peek       fp:len
  load
  save       dp:cnt

  peek       fp:index1
  store      sp:0
  copy       dp:i1, 4

  peek       fp:index2
  store      sp:0
  copy       dp:i2, 4

  peek       fp:s1
  store      sp:1

  peek       fp:s2
  store      sp:0

  peek       fp:len
  load       
  cmp        n:0
  jeq        labEnd

labNext:
  set        dp:tmp
  load       dp:i2
  read       1
  add        n:1
  save       dp:i2

  xswap      sp:1
  load       dp:i1
  write      1
  add        n:1
  save       dp:i1
  xswap      sp:1

  load       dp:cnt
  sub        n:1   
  save       dp:cnt
  cmp        n:0
  jne        labNext

labEnd:
  nsave      dp:tmp, 0

  xswap      sp:1
  set        dp:tmp
  load       dp:i1
  write      1

  close      []

end

procedure __wstr_equal (s1, s2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[s_len,index,ch,ch2]

  peek       fp:s1
  nlen       2
  save       dp:s_len

  peek       fp:s2
  nlen       2
  set        dp:s_len
  xcmp
  jne        labNotEqual

  sub        n:1

  nsave      dp:index, 0

  peek       fp:s1
  store      sp:0
  peek       fp:s2
  store      sp:1

labCheck:
  load       dp:index
  xcmp       dp:s_len
  jeq        labLoopEnd

  nsave      dp:ch, 0
  nsave      dp:ch2, 0

  set        dp:ch
  read       2

  xswap      sp:1

  set        dp:ch2
  read       2

  load
  xcmp       dp:ch 
  jne        labNotEqual

  nadd       dp:index, 1
  xswap      sp:1
  jump       labCheck

labLoopEnd:
  set        class:"system'BoolValue#true"
  jump       labEnd

labNotEqual:
   set       class:"system'BoolValue#false"

labEnd:
  close      []

end

procedure __wstr_less (s1, s2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[s_len,index,ch,ch2]

  peek       fp:s1
  nlen       2
  sub        n:1
  save       dp:s_len

  peek       fp:s2
  nlen       2
  sub        n:1
  set        dp:s_len
  xcmp
  jne        labNotLess

  nsave      dp:index, 0

  peek       fp:s1
  store      sp:0
  peek       fp:s2
  store      sp:1

labCheck:
  load       dp:index
  xcmp       dp:s_len
  jeq        labLoopEnd

  nsave      dp:ch, 0
  nsave      dp:ch2, 0

  set        dp:ch
  read       2

  xswap      sp:1

  set        dp:ch2
  read       2

  xswap      sp:1
  load
  xcmp       dp:ch
  jlt        labNotLess

  nadd       dp:index, 1
  jump       labCheck

labLoopEnd:
  set        dp:ch2
  load
  xcmp       dp:ch
  jeq        labNotLess

  set        class:"system'BoolValue#true"
  jump       labEnd

labNotLess:
   set       class:"system'BoolValue#false"

labEnd:
  close      []

end

procedure __wstr_copysubs (self, s1, s2, index, len)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp]

  peek       fp:index
  store      sp:0
  copy       dp:i1, 4
  nsave      dp:i2, 0

  peek       fp:s1
  store      sp:1

  peek       fp:s2
  store      sp:0

labNext:
  set        dp:tmp
  load       dp:i2
  read       2
  add        n:1
  save       dp:i2

  xswap      sp:1
  load       dp:i1
  write      2
  add        n:1
  save       dp:i1
  xswap      sp:1

  peek       fp:len
  load       
  xcmp       dp:i2
  jne        labNext

  nsave      dp:tmp, 0

  xswap      sp:1
  set        dp:tmp
  load       dp:i1
  write      2

  close      []

end

procedure __wstr_xcopysubs (self, s1, s2, index1, len, index2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp,cnt]

  peek       fp:len
  load
  save       dp:cnt

  peek       fp:index1
  store      sp:0
  copy       dp:i1, 4

  peek       fp:index2
  store      sp:0
  copy       dp:i2, 4

  peek       fp:s1
  store      sp:1

  peek       fp:s2
  store      sp:0

labNext:
  set        dp:tmp
  load       dp:i2
  read       2
  add        n:1
  save       dp:i2

  xswap      sp:1
  load       dp:i1
  write      2
  add        n:1
  save       dp:i1
  xswap      sp:1
  nadd       dp:i1, 1

  load       dp:cnt
  sub        n:1   
  save       dp:cnt
  cmp        n:0
  jne        labNext

  nsave      dp:tmp, 0

  xswap      sp:1
  set        dp:tmp
  load       dp:i1
  write      2

  close      []

end

procedure __intToByte

  peek       sp:1
  load
  and        n:0FFh
  peek       sp:2
  save

end

procedure __uintToByte

  peek       sp:1
  load
  and        n:0FFh
  peek       sp:2
  save

end

procedure __shortToByte

  peek       sp:1
  load
  and        n:0FFh
  peek       sp:2
  save

end

procedure __intToUInt

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __uintToInt

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __realTrunc (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  ftrunc     dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realRound (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fround     dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realAbs (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fabs       dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realSqrt (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fsqrt      dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realExp (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fexp       dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realLn (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fln        dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realSin (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fsin        dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realCos (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fcos       dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realArctan (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  farctan    dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realPi (self, r1)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  fpi        dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r1
  copy       __realSize

  close      []

end

procedure __longToByte

  peek       sp:1
  load
  and        n:0FFh
  peek       sp:2
  save

end

procedure __intToChar

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __intHash (self,n,r)

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __realHash (self,n,r)

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __strHash (self,s,r)

  peek       sp:1
  load
  and        n:255 
  peek       sp:2
  save

end

procedure __charToInt

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __longToInt

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __realToInt (self, r,retVal)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp]

  peek       fp:r
  nconf      dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:retVal
  copy       4

  close      []

end

procedure __intToShort

  peek       sp:1
  load
  and        n:0FFFFh
  peek       sp:2
  save

end

procedure __uintToShort

  peek       sp:1
  load
  and        n:0FFFFh
  peek       sp:2
  save

end

procedure __byteToShort

  peek       sp:1
  load
  and        n:0FFFFh
  peek       sp:2
  save

end

procedure __readIntPtr

  peek       sp:1
  get        i:0
  load
  peek       sp:2
  save

end

procedure __ptrCopyTo (self, arr, len)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  peek       fp:self
  get        i:0
  store      sp:0
  peek       fp:len
  load
  peek       fp:arr
  dcopy      1

  close      []

end

procedure __copySubStr (dest, index, len, sour)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp]

  peek       fp:index
  load
  save       dp:i1
  nsave      dp:i2, 0

  peek       fp:dest
  store      sp:1

  peek       fp:sour
  store      sp:0

labNext:
  set        dp:tmp
  load       dp:i1
  bread
  xswap      sp:1
  load       dp:i2
  write      1
  xswap      sp:1

  nadd       dp:i1, 1
  nadd       dp:i2, 1

  peek       fp:len
  load       
  xcmp       dp:i2
  jne        labNext

  close      []

end

procedure __copySubWStr (dest, index, len, sour)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp]

  peek       fp:index
  load
  save       dp:i1
  nsave      dp:i2, 0

  peek       fp:dest
  store      sp:1

  peek       fp:sour
  store      sp:0

labNext:
  set        dp:tmp
  load       dp:i1
  wread
  xswap      sp:1
  load       dp:i2
  write      2
  xswap      sp:1

  nadd       dp:i1, 1
  nadd       dp:i2, 1

  peek       fp:len
  load       
  xcmp       dp:i2
  jne        labNext

  close      []

end

procedure __loadCallStack (self, buffer, length, retVal)

  xflush     sp:0
  xflush     sp:1

  open       (3),[b],[l,ptr]

  peek       fp:length
  load
  save       dp:l
  peek       fp:buffer
  store      fp:b

  mov        frm
  $save      dp:ptr        // ; NOTE for 64bit it should be lsave dp

  call extern:LoadCallStackLA(*$ptr, b, *l) // ; NOTE for 64bit ptr should be treated as long
  peek       fp:retVal
  save

  close      []

end

procedure __symbol_load (self, s)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  call extern:LoadSymbolByStringLA(s)
  cmp  n:0
  jne  labExit

  peek       fp:s
  store      sp:1

  set        class : "system'SymbolLoaderException"
  store      sp:0

  set        mssgconst : "new[2]"
  throw

labExit:
  peek       fp:self
  save

  close      []

end

procedure __symbol_copy

  peek       sp:2
  load
  peek       sp:1
  save

end

procedure __symbol_dispatcher

  redirect

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp]
  save       dp:tmp
  get        i:0
  xcall
  load       dp:tmp
  close      []

  xrefresh   sp:0
  xrefresh   sp:1

  jump       vt:0

end

procedure __classref_load (self, s)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  call extern:LoadClassByStringLA(s)
  cmp  n:0
  jne  labExit

  peek       fp:s
  store      sp:1

  set        class : "system'TypeLoaderException"
  store      sp:0

  set        mssgconst : "new[2]"
  throw

labExit:
  peek       fp:self
  save

  close      []

end

procedure __classref_dispatcher

  redirect

  get        i:0
  store      sp:0
  jump       vt:0

end

procedure __message_load (self, s)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  call extern:LoadMessageLA(s)
  cmp  n:0
  jne  labExit

  set        class : "system'InvalidArgumentException"
  store      sp:0

  set        mssgconst : "new[1]"
  throw

labExit:
  peek       fp:self
  save

  close      []

end

procedure __mssgname_load(self, m)

  peek      fp:m
  loads
  peek      fp:self
  save

end

procedure __mssgname_dispatcher

  tstn        FUNCTION_MESSAGE
  jeq         labDefault

  loadv
  peek        sp:0
  jump        vt:0

labDefault:

  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  set        class : "system'MethodNotFoundException"
  store      sp:0

  set        mssgconst : "new[3]"
  throw

end

procedure __varg_readLength(varg, retVal)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp]

  nsave      dp:tmp, -1

  peek       fp:varg
  store      sp:0

labNext:
  nadd       dp:tmp, 1
  peek       sp:0
  load       dp:tmp
  xget
  cmp        terminator
  jne        labNext

  load       dp:tmp
  peek       fp:retVal
  save

  close      []

end

procedure __st_assign (self, s)

  peek      sp:1
  lload
  peek      sp:0
  lsave

end

procedure __gc_minor

  xflush     sp:0
  xflush     sp:1

  open       (2),[]
  system     1
  close      []

  xrefresh   sp:0
  xrefresh   sp:1

end

procedure __gc_full

  xflush     sp:0
  xflush     sp:1

  open       (2),[]
  system     2
  close      []

  xrefresh   sp:0
  xrefresh   sp:1

end

procedure __perm_vector_create

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[len]

  nsave      dp:len, 10
  set        dp:len  
  store      sp:0
  xcreate    class:"system'runtime'$private'PermVectorArray"

  close      []

end

procedure __perm_array_set

 peek       sp:1
 load
 peek       sp:2
 swap       sp:0
 xassign

end

procedure __perm_array_refer (self,index,retVal)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[ptr:ptr_size,ptr_index:8]

  set        fp:self
  $load                   // ; get the 
  $save      dp:ptr

  // ; the code should support both for 32 and 64 bit mode
  // ; so ptr_index has the maximal possible size
  peek       fp:index
  load
  mul        n:ptr_size
  convl
  lsave      dp:ptr_index

  set        dp:ptr_index
  store      sp:0
  iadd       dp:ptr, ptr_size

  $load      dp:ptr
  peek       fp:retVal
  $save

  close      []

end

procedure __mssg_closure

  load
  peek       sp:0
  jump       vt:0

end

procedure __saving_closure(obj, args)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  load
  peek       fp:obj
  store      sp:0
  peek       fp:args
  xassign
  peek       sp:0

  close      []

end

procedure __alloc_closure

  load
  system     5

end

procedure __assign_closure

  load
  peek       sp:0

  alloc      i:1
  store      sp:0

  set        fp:0
  xassign

  free       i:1

end

procedure __thread_create(self,arg,flags,ptr)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  call extern:CreateThreadLA (
     *arg, 
     procedure:"system'core_routines'thread_start",
     *flags)

  peek       fp:ptr
  $save

  close      []

end

procedure __closuretape

  tstn       FUNCTION_MESSAGE
  jeq        labDefault

  xflush     sp:0
  xflush     sp:1

  open       (32),[target],[index,len,mssg]
      
  save       dp:mssg
    
  len
  save       dp:len
  nsave      dp:index, 0

  store      fp:target

  // ; copy the call stack
  load       dp:mssg
  mlen
  xassignsp
  alloc      i:1
  store      sp:0
  set        fp:1
  swap       sp:0
  dtrans
  swap       sp:0
  set        terminator
  swap       sp:0
  xassign
  free       i:1

labNext:
  peek       fp:target

  load       dp:len
  xcmp       dp:index
  jle        labEnd

  load       dp:index
  xget
  nadd       dp:index, 1

  vcall      mssg:"function:params:#invoke<system'Object>[0]", class:"system'dynamic'TapeFunction"
  store      sp:0

  jump       labNext

labEnd:

  close      []
  quit
	
labDefault:
  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  set        class : "system'MethodNotFoundException"
  store      sp:0

  set        mssgconst : "new[3]"
  throw

end

procedure __tape_eval(self, buffer, len)

  xflush     sp:0
  xflush     sp:1

  open       (4),[],[index,command,size,ptr]

  // ; alloc stack
  peek       fp:buffer
  load
  dalloc

  nsave      dp:index, 4
  nsave      dp:ptr, -1

  // while (index < len) {
labNext:
  peek       fp:len
  load       
  xcmp       dp:index
  jle        labEnd

  //command := buffer[index];
  peek       fp:buffer
  load       dp:index
  xload
  and        n:0FFh
  save       dp:command

  // index += 1;
  nadd       dp:index, 1

  // size := buffer[index];
  load       dp:index
  xload
  save       dp:size

  // index += 4;
  nadd       dp:index, 4

  // check attribute type
  load       dp:command
  cmp        n:020h
  jge        labSpecial

  // copy arguments
  xassignsp
  store      sp:0
  load       dp:ptr
  add        n:1
  xset       fp:0
  swap       sp:0
  load       dp:command
  dtrans

  set        dp:command
  store      sp:0
  iadd       dp:ptr, 4

  // loadClass
  call       extern:LoadClassByBufferLA(buffer, *index, *size)
  cmp        n:0
  jeq        labNotFound 

  // ; !! NOTE : we taking advantage that the operation with sp:0 does not affect the real stack
  save       sp:0
  peek       sp:0
  xrefresh   sp:0

  mov        mssg : "function:#constructor[0]"
  xadd       dp:command

  call       vt:0

  // ; store the result
  load       dp:ptr
  store      sp:0
  set        fp:0
  xassign
  nadd       dp:ptr, -1

  // i += size
  set        dp:size
  store      sp:0
  iadd       dp:index, 4

  jump       labNext

labSpecial:
  peek        fp:buffer
  store       sp:3    
  set         dp:size
  store       sp:2
  set         dp:index
  store       sp:1
  set         class:"system'text'UTF8Encoding"
  store       sp:0
  mov         mssg:"toString<system'IntNumber,system'IntNumber,'$auto'system@Array#1&system@ByteNumber>[4]"
  call        mssg:"toString<system'IntNumber,system'IntNumber,'$auto'system@Array#1&system@ByteNumber>[4]", class:"system'text'UTF8Encoding"

  // ; store the result
  load       dp:ptr
  store      sp:0
  set        fp:0
  xassign
  nadd       dp:ptr, -1

  // i += size
  set        dp:size
  store      sp:0
  iadd       dp:index, 4

  jump       labNext

labNotFound:
  // UTF8Encoding.toString(index,size,buffer)
  peek       fp:buffer
  store      sp:3    
  set        dp:size
  store      sp:2
  set        dp:index
  store      sp:1
  set        class:"system'text'UTF8Encoding"
  store      sp:0
  mov        mssg:"toString<system'IntNumber,system'IntNumber,'$auto'system@Array#1&system@ByteNumber>[4]"
  call       mssg:"toString<system'IntNumber,system'IntNumber,'$auto'system@Array#1&system@ByteNumber>[4]", class:"system'text'UTF8Encoding"
  store      sp:1
  set        class : "system'TypeLoaderException"
  store      sp:0

  set        mssgconst : "new[2]"
  throw

labEnd:
  load       dp:ptr
  add        n:1
  set        fp:0
  xget

  close      []
  quit

end

procedure critical_exception_handler

  cmp         n:EXCEPTION_ACCESS_VIOLATION
  jeq         labAccessViolation

  cmp         n:ELENA_ERR_DIVIDE_BY_ZERO
  jeq         labDivisionByZero

  cmp         n:ELENA_ERR_OUT_OF_MEMORY
  jeq         labOutOfMemory

  set         class : "system'CriticalException"
  store       sp:0
  set         mssgconst : "new[1]"
  throw

labAccessViolation:
  set         class : "system'NilReferenceException"
  store       sp:0
  set         mssgconst : "new[1]"
  throw

labDivisionByZero:
  set         class : "system'DivisionByZeroException"
  store       sp:0
  set         mssgconst : "new[1]"
  throw

labOutOfMemory:
  set         class : "system'OutOfMemoryException"
  store       sp:0
  set         mssgconst : "new[0]"
  throw

end

procedure default_exception_handler

  call extern:ExitLA (err_ret)

end

procedure startUpSymbols

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i,len]

  nsave      dp:i, 0

  set        marray:"$forwards'meta$startUpSymbols"

  load
  save       dp:len

labNext:
  nadd       dp:i, 1

  load       dp:i
  set        marray:"$forwards'meta$startUpSymbols"
  xget
  xcall

  load       dp:len
  xcmp       dp:i
  jne        labNext

  close      []
  quit

end

procedure func_invoker(arg)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  peek       fp:arg
  get        i:0
  mov        mssg:"function:#invoke[0]" 
  call       vt:0 

  close      []
  quit

end

procedure thread_start

  xloadarg    sp:1

  system      3

  open header [arg1],[ptr,envptr,ex_struct:ex_struct_size]
  
  $save       dp:ptr

  xhook       dp:ex_struct, procedure:"system'core_routines'default_exception_handler"

  mov         env
  save        dp:envptr
  set         dp:envptr
  store       fp:arg1

  call extern:StartThreadLA (
     *arg1, 
     procedure:"system'core_routines'critical_exception_handler",
     procedure:"system'core_routines'func_invoker",
     *ptr)

  unhook

  close       []
  quit

end

symbol sta_start

  system      4

  open header [arg1],[argv, envptr,ex_struct:ex_struct_size]

  xhook       dp:ex_struct, procedure:"system'core_routines'default_exception_handler"

  mov         env
  save        dp:envptr
  set         dp:envptr
  store       fp:arg1

  call extern:InitializeSTLA (
     *arg1,
     symbol:"$auto'startUpSymbol",
     procedure:"system'core_routines'critical_exception_handler")

  close       []

end

symbol mta_start

  system      4

  // ; initialize TLS entry
  mov         n:0
  system      3

  open header [arg1],[envptr,ex_struct:ex_struct_size]
  
  xhook       dp:ex_struct, procedure:"system'core_routines'default_exception_handler"

  mov         env
  save        dp:envptr
  set         dp:envptr
  store       fp:arg1

  call extern:InitializeMTLA (
     *arg1,
     procedure:"system'core_routines'startUpSymbols",
     procedure:"system'core_routines'critical_exception_handler")

  close       []

end

symbol vm_sta_start

  open header [arg1],[envptr,ex_struct:ex_struct_size]
  
  xhook       dp:ex_struct, procedure:"system'core_routines'default_exception_handler"

  mov         env
  save        dp:envptr
  set         dp:envptr
  store       fp:arg1

  call extern:InitializeVMSTLA (
     *arg1, 
     constdump:"$elena'meta$startUpTape",
     pstr:"system'core_routines'critical_exception_handler")

  close       []

end
