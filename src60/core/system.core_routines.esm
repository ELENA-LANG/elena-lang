//        ELENA Language 6.0
//      inline system library

define EXCEPTION_ACCESS_VIOLATION  101h;
define ELENA_ERR_DIVIDE_BY_ZERO    102h;
define ELENA_ERR_OUT_OF_MEMORY     103h;
define ELENA_ERR_STACKOVERFLOW     105h;

define FUNCTION_MESSAGE       00000020h;
define PROPERTY_MESSAGE       00000080h;
define VARIADIC_MESSAGE       00000040h;
define PROP_ARG_MASK          000000DFh;
define ARG_MASK               0000001Fh;

define ex_struct_size32              16; 
define ex_struct_size64              32; 

define page_size32                   16;
define page_size64                   32;

define ptr_size32                     4;
define ptr_size64                     8;
                                      
define get_prop_mssg                081h;
define set_prop_mssg                082h;
define variadic_mssg                040h;

define __realSize                     8;

define elMessage              00200000h;
define elSubject              01000000h;

define err_ret          -1;
define nameconst_index  -1;

define WM_CREATE         1;

procedure __object_dispatcher

  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  xstore     sp:0, class : "system'MethodNotFoundException"

  set        mssgconst : "new[3]"
  throw

end

procedure __object_equal

  peek        sp:0
  cmp         sp:1
  seleq       class:"system'BoolValue#true", class:"system'BoolValue#false"

end

procedure __object_class

  peek        sp:0
  class

end

procedure __object_parentclass

  peek        sp:0
  class
  parent

end

procedure __object_parent

  peek        sp:0
  parent

end

procedure __object_instanceOf

  peek        sp:0
  class
  cmp         sp:1
  seleq       class:"system'BoolValue#true", class:"system'BoolValue#false"

end

procedure __exception_handler

  xflush          sp:0
  xflush          sp:1
  open            :3, :0 
  store           fp:1 

  peek            fp:-2 
  tst             mssg:"function:#try_invoke[2]"
  jne             Lab01

  xstore          sp:1, mssgconst:"fallback[2]"

  peek            fp:1 
  store           sp:0 
  peek            fp:-2 
  mov             mssg:"function:#try_invoke[2]" 
  call            vt:0 

  jump            Lab00

Lab01:
  peek            fp:1 
  store           sp:0 
  peek            fp:-2 
  mov             mssg:"function:#invoke[1]" 
  call            vt:0 

Lab00:
  close           :0 
  quit             

end

procedure __lazy_dispatcher

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp]
  save       dp:tmp
  vcall      mssg:"function:#invoke[0]", class:"system'BaseLazyExpression"
  load       dp:tmp  
  close      []

  xrefresh   sp:0
  xrefresh   sp:1

  jump       vt:0

end

procedure __exception_raise

  xflush     sp:0
  xflush     sp:1

  open       (2),[]
  throw
  close      []

end

procedure __message_dispatcher

  tst         n:FUNCTION_MESSAGE
  jeq         labDefault

  loadv
  xcmp
  jne         labDefault

  peek        sp:0
  jump        vt:0

labDefault:

  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  xstore     sp:0, class : "system'MethodNotFoundException"

  set        mssgconst : "new[3]"
  throw

end

procedure __ext_message_dispatcher

  tst         n:FUNCTION_MESSAGE
  jeq         labDefault

  loadv
  xcmp
  jne         labDefault

  get         i:1
  xjump

labDefault:

  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  xstore     sp:0, class : "system'MethodNotFoundException"

  set        mssgconst : "new[3]"
  throw

end

procedure __extensionvar

  xstore     i:0
  get        i:1
  or         n:FUNCTION_MESSAGE

  jump       vt:0

end

procedure __extension

  store      sp:0

  get        i:0
  redirect

  peek       sp:0
  get        i:1

  jump       vt:0

end

procedure __str_equal (s1, s2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[s_len,index,ch,ch2]

  peek       fp:s1
  nlen       1
  save       dp:s_len

  peek       fp:s2
  nlen       1
  set        dp:s_len
  xcmp
  jne        labNotEqual

  sub        n:1

  nsave      dp:index, 0

  peek       fp:s1
  store      sp:0
  peek       fp:s2
  store      sp:1

labCheck:
  load       dp:index
  xcmp       dp:s_len
  jeq        labLoopEnd

  nsave      dp:ch, 0
  nsave      dp:ch2, 0

  set        dp:ch
  read       1

  xswap      sp:1

  set        dp:ch2
  read       1

  load
  xcmp       dp:ch 
  jne        labNotEqual

  nadd       dp:index, 1
  xswap      sp:1
  jump       labCheck

labLoopEnd:
  set        class:"system'BoolValue#true"
  jump       labEnd

labNotEqual:
   set       class:"system'BoolValue#false"

labEnd:
  close      []

end

procedure __str_less (s1, s2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[s_len,index,ch,ch2]

  peek       fp:s1
  nlen       1
  sub        n:1
  save       dp:s_len

  nsave      dp:index, 0

  peek       fp:s1
  store      sp:0
  peek       fp:s2
  store      sp:1

labCheck:
  load       dp:index
  xcmp       dp:s_len
  jeq        labLess

  nsave      dp:ch, 0
  nsave      dp:ch2, 0

  set        dp:ch
  read       1

  xswap      sp:1

  set        dp:ch2
  read       1

  xswap      sp:1
  load
  xcmp       dp:ch
  jlt        labNotLess

  jne        labLess

  nadd       dp:index, 1
  jump       labCheck

labLess:
  set        class:"system'BoolValue#true"
  jump       labEnd

labNotLess:
   set       class:"system'BoolValue#false"

labEnd:
  close      []

end

procedure __str_copysubs (self, s1, s2, index, len)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp]

  peek       fp:index
  store      sp:0
  copy       dp:i1, 4
  nsave      dp:i2, 0

  peek       fp:s1
  store      sp:1

  peek       fp:s2
  store      sp:0

  peek       fp:len
  load       
  cmp        n:0
  jeq        labEnd

labNext:
  set        dp:tmp
  load       dp:i2
  read       1
  add        n:1
  save       dp:i2

  xswap      sp:1
  load       dp:i1
  write      1
  add        n:1
  save       dp:i1
  xswap      sp:1

  peek       fp:len
  load       
  xcmp       dp:i2
  jne        labNext

labEnd:
  nsave      dp:tmp, 0

  xswap      sp:1
  set        dp:tmp
  load       dp:i1
  write      1

  close      []

end

procedure __str_xcopysubs (self, s1, s2, index1, len, index2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp,cnt]

  peek       fp:len
  load
  save       dp:cnt

  peek       fp:index1
  store      sp:0
  copy       dp:i1, 4

  peek       fp:index2
  store      sp:0
  copy       dp:i2, 4

  peek       fp:s1
  store      sp:1

  peek       fp:s2
  store      sp:0

  peek       fp:len
  load       
  cmp        n:0
  jeq        labEnd

labNext:
  set        dp:tmp
  load       dp:i2
  read       1
  add        n:1
  save       dp:i2

  xswap      sp:1
  load       dp:i1
  write      1
  add        n:1
  save       dp:i1
  xswap      sp:1

  load       dp:cnt
  sub        n:1   
  save       dp:cnt
  cmp        n:0
  jne        labNext

labEnd:
  nsave      dp:tmp, 0

  xswap      sp:1
  set        dp:tmp
  load       dp:i1
  write      1

  close      []

end

procedure __wstr_equal (s1, s2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[s_len,index,ch,ch2]

  peek       fp:s1
  nlen       2
  save       dp:s_len

  peek       fp:s2
  nlen       2
  set        dp:s_len
  xcmp
  jne        labNotEqual

  sub        n:1

  nsave      dp:index, 0

  peek       fp:s1
  store      sp:0
  peek       fp:s2
  store      sp:1

labCheck:
  load       dp:index
  xcmp       dp:s_len
  jeq        labLoopEnd

  nsave      dp:ch, 0
  nsave      dp:ch2, 0

  set        dp:ch
  read       2

  xswap      sp:1

  set        dp:ch2
  read       2

  load
  xcmp       dp:ch 
  jne        labNotEqual

  nadd       dp:index, 1
  xswap      sp:1
  jump       labCheck

labLoopEnd:
  set        class:"system'BoolValue#true"
  jump       labEnd

labNotEqual:
   set       class:"system'BoolValue#false"

labEnd:
  close      []

end

procedure __wstr_less (s1, s2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[s_len,index,ch,ch2]

  peek       fp:s1
  nlen       2
  sub        n:1
  save       dp:s_len

  nsave      dp:index, 0

  peek       fp:s1
  store      sp:0
  peek       fp:s2
  store      sp:1

labCheck:
  load       dp:index
  xcmp       dp:s_len
  jeq        labLess

  nsave      dp:ch, 0
  nsave      dp:ch2, 0

  set        dp:ch
  read       2

  xswap      sp:1

  set        dp:ch2
  read       2

  xswap      sp:1
  load
  xcmp       dp:ch
  jlt        labNotLess

  jne        labLess

  nadd       dp:index, 1
  jump       labCheck

labLess:
  set        class:"system'BoolValue#true"
  jump       labEnd

labNotLess:
   set       class:"system'BoolValue#false"

labEnd:
  close      []

end

procedure __wstr_copysubs (self, s1, s2, index, len)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp]

  peek       fp:index
  store      sp:0
  copy       dp:i1, 4
  nsave      dp:i2, 0

  peek       fp:s1
  store      sp:1

  peek       fp:s2
  store      sp:0

  peek       fp:len
  load       
  cmp        n:0
  jeq        labEnd

labNext:
  set        dp:tmp
  load       dp:i2
  read       2
  add        n:1
  save       dp:i2

  xswap      sp:1
  load       dp:i1
  write      2
  add        n:1
  save       dp:i1
  xswap      sp:1

  peek       fp:len
  load       
  xcmp       dp:i2
  jne        labNext

labEnd:
  nsave      dp:tmp, 0

  xswap      sp:1
  set        dp:tmp
  load       dp:i1
  write      2

  close      []

end

procedure __wstr_xcopysubs (self, s1, s2, index1, len, index2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp,cnt]

  peek       fp:len
  load
  save       dp:cnt

  peek       fp:index1
  store      sp:0
  copy       dp:i1, 4

  peek       fp:index2
  store      sp:0
  copy       dp:i2, 4

  peek       fp:s1
  store      sp:1

  peek       fp:s2
  store      sp:0

  peek       fp:len
  load       
  cmp        n:0
  jeq        labEnd

labNext:
  set        dp:tmp
  load       dp:i2
  read       2
  add        n:1
  save       dp:i2

  xswap      sp:1
  load       dp:i1
  write      2
  add        n:1
  save       dp:i1
  xswap      sp:1

  load       dp:cnt
  sub        n:1   
  save       dp:cnt
  cmp        n:0
  jne        labNext

labEnd:
  nsave      dp:tmp, 0

  xswap      sp:1
  set        dp:tmp
  load       dp:i1
  write      2

  close      []

end

procedure __intToByte

  peek       sp:1
  load
  and        n:0FFh
  peek       sp:2
  save

end

procedure __intToSByte

  peek       sp:1
  bload
  peek       sp:2
  save

end

procedure __uintToByte

  peek       sp:1
  load
  and        n:0FFh
  peek       sp:2
  save

end

procedure __shortToByte

  peek       sp:1
  load
  and        n:0FFh
  peek       sp:2
  save

end

procedure __intToUInt

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __uintToInt

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __ushortToInt

  peek       sp:1
  load
  and        n:0FFFFh
  peek       sp:2
  save

end

procedure __realTrunc (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  ftrunc     dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realRound (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fround     dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realAbs (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fabs       dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realSqrt (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fsqrt      dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realExp (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fexp       dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realLn (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fln        dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realSin (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fsin        dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realCos (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  fcos       dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realArctan (self, r1, r2)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  peek       fp:r1
  store      sp:0

  farctan    dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r2
  copy       __realSize

  close      []

end

procedure __realPi (self, r1)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp:__realSize]

  fpi        dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:r1
  copy       __realSize

  close      []

end

procedure __longToByte

  peek       sp:1
  load
  and        n:0FFh
  peek       sp:2
  save

end

procedure __intToChar

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __setHandleDirectly

  peek       sp:1
  load
  peek       sp:0
  $save

end

procedure __intToMssg

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __intHash (self,n,r)

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __longHash (self,n,r)

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __realHash (self,n,r)

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __strHash (self,s,r)

  peek       sp:1
  load
  and        n:255 
  peek       sp:2
  save

end

procedure __wstrHash (self,s,r)

  peek       sp:1
  load
  and        n:0FFFFh
  peek       sp:2
  save

end

procedure __charToInt

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __longToInt

  peek       sp:1
  load
  peek       sp:2
  save

end

procedure __realToInt (self, r,retVal)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp]

  peek       fp:r
  nconf      dp:tmp

  set        dp:tmp
  store      sp:0
  peek       fp:retVal
  copy       4

  close      []

end

procedure __intToShort

  peek       sp:1
  load
  and        n:0FFFFh
  peek       sp:2
  save

end

procedure __intToUShort

  peek       sp:1
  load
  and        n:0FFFFh
  peek       sp:2
  save

end

procedure __uintToShort

  peek       sp:1
  load
  and        n:0FFFFh
  peek       sp:2
  save

end

procedure __byteToShort

  peek       sp:1
  load
  and        n:0FFFFh
  peek       sp:2
  save

end

procedure __readIntPtr(ptr, retVal)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]
  peek       fp:ptr
  get        i:0
  xstore     i:0 
  $load      sp:0
  peek       fp:retVal
  $save

  close      []

end

procedure __readIntPtrVal

  peek       sp:0
  get        i:0
  load
  peek       sp:1
  save
  peek       sp:0

end

procedure __readPtrVal

  peek       sp:0
  get        i:0
  load
  peek       sp:1
  save
  peek       sp:0

end

procedure __readRealPtrVal

  peek       sp:0
  get        i:0
  lload
  peek       sp:1
  lsave
  peek       sp:0

end

procedure __readLongPtrVal

  peek       sp:0
  get        i:0
  lload
  peek       sp:1
  lsave
  peek       sp:0

end

procedure __clearPtr(self)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  xstore     sp:0, nil
  peek       fp:self
  xassign    i:0

  close      []

end

procedure __assignPtr(self, ptr)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  peek       fp:ptr
  store      sp:0
  peek       fp:self
  xassign    i:0

  close      []

end

procedure __ptrCopyTo (self, arr, len)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  peek       fp:self
  get        i:0
  store      sp:0
  peek       fp:len
  load
  peek       fp:arr
  dcopy      1

  close      []

end

procedure __ptrCopySubTo (self, arr, index, len)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp]

  peek       fp:self
  get        i:0
  store      sp:0
  $load      sp:0
  $save      dp:tmp
  peek       fp:index
  load
  xadd       dp:tmp
  $save      sp:0
  peek       fp:len
  load
  peek       fp:arr
  dcopy      1

  close      []

end

procedure __copySubStr (self, dest, index, len, sour)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp]

  peek       fp:index
  load
  save       dp:i1
  nsave      dp:i2, 0

  peek       fp:dest
  store      sp:1

  peek       fp:sour
  store      sp:0

labNext:
  set        dp:tmp
  load       dp:i1
  bread
  xswap      sp:1
  load       dp:i2
  write      1
  xswap      sp:1

  nadd       dp:i1, 1
  nadd       dp:i2, 1

  peek       fp:len
  load       
  xcmp       dp:i2
  jne        labNext

  close      []

end

procedure __copySubStr2 (self, dest, index, len, sour)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp]

  peek       fp:len
  load
  cmp        n:0
  jeq        labEnd

  peek       fp:index
  load
  save       dp:i2
  nsave      dp:i1, 0

  peek       fp:dest
  store      sp:1

  peek       fp:sour
  store      sp:0

labNext:
  set        dp:tmp
  load       dp:i1
  bread
  xswap      sp:1
  load       dp:i2
  write      1
  xswap      sp:1

  nadd       dp:i1, 1
  nadd       dp:i2, 1

  peek       fp:len
  load       
  xcmp       dp:i1
  jne        labNext

labEnd:
  close      []

end

procedure __copySubWStr (self, dest, index, len, sour)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i1,i2,tmp]

  peek       fp:index
  load
  save       dp:i1
  nsave      dp:i2, 0

  peek       fp:dest
  store      sp:1

  peek       fp:sour
  store      sp:0

labNext:
  set        dp:tmp
  load       dp:i1
  wread
  xswap      sp:1
  load       dp:i2
  write      2
  xswap      sp:1

  nadd       dp:i1, 1
  nadd       dp:i2, 1

  peek       fp:len
  load       
  xcmp       dp:i2
  jne        labNext

  close      []

end

procedure __loadCallStack (self, buffer, length, retVal)

  xflush     sp:0
  xflush     sp:1

  open       (3),[b],[l,ptr]

  peek       fp:length
  load
  save       dp:l
  peek       fp:buffer
  store      fp:b

  mov        frm
  $save      dp:ptr        // ; NOTE for 64bit it should be lsave dp

  call extern:LoadCallStackLA(*$ptr, b, *l) // ; NOTE for 64bit ptr should be treated as long
  peek       fp:retVal
  save

  close      []

end

procedure __symbol_load (self, s)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  call extern:LoadSymbolByStringLA(s)
  cmp  n:0
  jne  labExit

  peek       fp:s
  store      sp:1

  xstore     sp:0, class : "system'SymbolLoaderException"

  set        mssgconst : "new[2]"
  throw

labExit:
  peek       fp:self
  $save

  close      []

end

procedure __symbol_copy

  peek       sp:1
  $load
  peek       sp:0
  $save

end

procedure __symbol_equal

  peek        sp:0
  $load
  peek        sp:1
  $xcmp
  seleq       class:"system'BoolValue#true", class:"system'BoolValue#false"

end

procedure __symbol_dispatcher

  redirect

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp]
  save       dp:tmp
  get        i:0
  xcall
  load       dp:tmp
  close      []

  xrefresh   sp:0
  xrefresh   sp:1

  jump       vt:0

end

procedure __classref_load (self, s)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  call extern:LoadClassByStringLA(s)
  cmp  n:0
  jne  labExit

  peek       fp:s
  store      sp:1

  xstore     sp:0, class : "system'TypeLoaderException"

  set        mssgconst : "new[2]"
  throw

labExit:
  peek       fp:self
  save

  close      []

end

procedure __classref_dispatcher

  redirect

  get        i:0
  store      sp:0
  jump       vt:0

end

procedure __loadPackageInfo(self, ptr, index)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  peek       fp:index
  load  
  peek       fp:ptr
  get        i:0
  xget       

  close      []

end

procedure __message_load (self, s)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  call extern:LoadMessageLA(s)
  cmp  n:0
  jne  labExit

  xstore     sp:0, class : "system'InvalidArgumentException"

  set        mssgconst : "new[1]"
  throw

labExit:
  peek       fp:self
  save

  close      []

end

procedure __mssgname_load(self, m)

  peek      sp:1
  loads
  peek      sp:0
  save

end

procedure __messagename_loadbystr (self, s)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  call extern:LoadActionLA(s)
  cmp  n:0
  jne  labExit

  xstore     sp:0, class : "system'InvalidArgumentException"

  set        mssgconst : "new[1]"
  throw

labExit:
  peek       fp:self
  save

  close      []

end

procedure __mssgname_getprop (self, mssg)

  mov        n:1
  loadv
  or         n:get_prop_mssg
  peek       sp:1
  save

end

procedure __mssgname_setprop (self, mssg)

  mov        n:2
  loadv
  or         n:set_prop_mssg
  peek       sp:1
  save

end

procedure __mssgname_variadic (self, mssg)

  mov        n:2
  loadv
  or         n:variadic_mssg
  peek       sp:1
  save

end

procedure __mssgname_dispatcher

  tst         n:FUNCTION_MESSAGE
  jeq         labDefault

  loadv
  peek        sp:0
  jump        vt:0

labDefault:

  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  xstore     sp:0, class : "system'MethodNotFoundException"

  set        mssgconst : "new[3]"
  throw

end

procedure __varg_readLength(varg, retVal)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[tmp]

  nsave      dp:tmp, -1

  peek       fp:varg
  store      sp:0

labNext:
  nadd       dp:tmp, 1
  peek       sp:0
  load       dp:tmp
  xget
  cmp        terminator
  jne        labNext

  load       dp:tmp
  peek       fp:retVal
  save

  close      []

end

procedure __st_assign (self, s)

  peek      sp:1
  lload
  peek      sp:0
  lsave

end

procedure __gc_minor

  xflush     sp:0
  xflush     sp:1

  open       (2),[]
  system     1
  close      []

  xrefresh   sp:0
  xrefresh   sp:1

end

procedure __gc_full

  xflush     sp:0
  xflush     sp:1

  open       (2),[]
  system     2
  close      []

  xrefresh   sp:0
  xrefresh   sp:1

end

procedure __perm_vector_create

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[len]

  nsave      dp:len, 10
  set        dp:len  
  store      sp:0
  xcreate    class:"system'runtime'$private'PermVectorArray"

  close      []

end

procedure __perm_array_set

 peek       sp:1
 load
 peek       sp:2
 swap       sp:0
 xassign

end

procedure __perm_array_clear

 peek       sp:1
 load
 set        nil
 swap       sp:0
 xassign

end

procedure __perm_array_refer (self,index,retVal)

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[ptr:ptr_size,ptr_index:8]

  set        fp:self
  $load                   // ; get the 
  $save      dp:ptr

  // ; the code should support both for 32 and 64 bit mode
  // ; so ptr_index has the maximal possible size
  peek       fp:index
  load
  mul        n:ptr_size
  convl
  lsave      dp:ptr_index

  set        dp:ptr_index
  store      sp:0
  iadd       dp:ptr, ptr_size

  $load      dp:ptr
  peek       fp:retVal
  $save

  close      []

end

procedure __mssg_closure

  load
  peek       sp:0
  jump       vt:0

end

procedure __funcmssg_closure

  xflush     sp:0
  xflush     sp:1

  alloc      i:1
  store      sp:0

  mov        n:4
  xload

  set        fp:0
  neg
  xget

  swap       sp:0
  load
  peek       sp:0

  free       i:1
  xrefresh   sp:0
  xrefresh   sp:1

  jump       vt:0

end

procedure __ext_closure

  xflush     sp:0
  xflush     sp:1

  alloc     i:1
  xstore    i:1
  get       i:0
  load
  or        n:FUNCTION_MESSAGE
  peek      sp:0
  free      i:1

  xrefresh  sp:0
  xrefresh  sp:1

  jump      vt:0

end

procedure __extdispatcher

  xflush     sp:0
  xflush     sp:1

  alloc     i:1
  xstore    i:0

// ; temporally commented out to allow call from interpreter tape
//  // check if it is invoke
//  and        SPECIAL_MESSAGE
//  ifn        labDefault 0 

  loadv
  xcmp      sp:0
  jne       labDefault

  free      i:1

  xrefresh  sp:0
  xrefresh  sp:1

  xdispatch i:1

  jump      labDefault2

labDefault:
  load      sp:0
  free      i:1

labDefault2:
  peek      sp:0
  redirect 

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  xstore     sp:0, class : "system'MethodNotFoundException"

  set        mssgconst : "new[3]"
  throw

end

procedure __vextdispatcher (arg)

  xflush     sp:0
  xflush     sp:1

  tst        n:VARIADIC_MESSAGE
  jeq        labUnboxing

  xdispatch  i:1, variadic
  jump       labError

labUnboxing:
  open       (2),[target],[mssg]

  store      fp:target
  save       dp:mssg

  and        n:ARG_MASK
  add        n:1
  dalloc
  set        sp:0
  alloc      i:1
  store      sp:0
  set        fp:arg
  swap       sp:0
  sub        n:1
  dtrans
  swap       sp:0
  set        terminator
  swap       sp:0
  xassign
  free       i:1

  load       dp:mssg
  and        n:0FFFFFFE0h
  or         n:082h

  peek       fp:target
  xrefresh   sp:0
  xrefresh   sp:1

  xdispatch  i:1

  close      []
  $clear
  quit

labError:
  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  xstore     sp:0, class : "system'MethodNotFoundException"

  set        mssgconst : "new[3]"
  throw

end

procedure __saving_closure(obj, args)

  xflush     sp:0
  xflush     sp:1

  load
  set        sp:0

  alloc      i:1
  xstore     i:0
  xassign

  free       i:1

  xrefresh   sp:0
  xrefresh   sp:1
  peek       sp:0

end

procedure __copytostack_closure(obj, args)

  xflush     sp:0
  xflush     sp:1

  xopen      (32),[target],[index,len,mssg,tmp]

  mov        n:4
  xload
  save       dp:tmp
  load

  set        sp:0
  alloc      i:2

  store      sp:1

  set        fp:0
  neg
  xget
  store      sp:0

  peek       sp:1
  load       dp:tmp
  xassign

  free       i:2

  xrefresh   sp:0
  xrefresh   sp:1

  peek       sp:0

end

procedure __local_closure(obj, args)

  xflush     sp:0
  xflush     sp:1

  load
  set        fp:0
  neg
  xget

end

procedure __alloc_closure

  xflush     sp:0
  xflush     sp:1

  load
  system     5

  xrefresh   sp:0
  xrefresh   sp:1

  peek       sp:0

end

procedure __assign_closure

  load
  peek       sp:0

  alloc      i:1
  store      sp:0

  set        fp:0
  neg
  xassign

  free       i:1
  peek       sp:0

end

procedure __dynamicmssg_closure

  xflush     sp:0
  xflush     sp:1

  load
  set        fp:0
  neg
  xget
  load
  peek       sp:0
  jump       vt:0

end

procedure __exit_closure

  xflush     sp:0
  xflush     sp:1

  peek       sp:0

  xopen      (32),[target],[index,len,mssg,tmp]

  load       dp:len
  save       dp:index 

end

procedure __jumpifnot_closure

  xflush     sp:0
  xflush     sp:1

  load
  peek       sp:0

  xopen      (32),[target],[index,len,mssg,tmp]

  cmp        class:"system'BoolValue#false"   
  jne        labSkip

  xadd       dp:index
  save       dp:index

labSkip:

end

procedure __jump_closure

  xflush     sp:0
  xflush     sp:1

  load
  peek       sp:0

  xopen      (32),[target],[index,len,mssg,tmp]

  xadd       dp:index
  save       dp:index

labSkip:

end

procedure __thread_create(self,arg,flags,stackSize,ptr)

  xflush     sp:0
  xflush     sp:1

  open       (2),[]

  // ; == enter GC critical section ==
  system      6 

  call extern:CreateThreadLA (
     *arg, 
     procedure:"system'core_routines'thread_start",
     *stackSize,
     *flags)

  system      7  
  // ; === leave GC critical section ===

  peek       fp:ptr
  $save

  close      []

end

procedure __closuretape

  tst        n:FUNCTION_MESSAGE
  jeq        labDefault

  xflush     sp:0
  xflush     sp:1

  open       (32),[target],[index,len,mssg,tmp]
      
  save       dp:mssg
    
  len
  save       dp:len
  nsave      dp:index, 0

  store      fp:target

  // ; copy the call stack
  load       dp:mssg
  mlen

  set        fp:2
  store      sp:2

  set        fp:-1
  store      sp:1

  cmp        n:0
  jeq        labCopyEnd

labCopy:
  add        n:-1

  peek       sp:1
  xget
  store      sp:0

  neg
  peek       sp:2
  xassign
  neg

  cmp        n:0
  jne        labCopy

labCopyEnd:
  xrefresh   sp:0
  xrefresh   sp:1

  set        sp:0
  alloc      i:1
  store      sp:0
  set        terminator
  swap       sp:0
  xassign    i:0
  free       i:1

labNext:
  peek       fp:target

  load       dp:len
  xcmp       dp:index
  jle        labEnd

  load       dp:index
  xget
  nadd       dp:index, 1

  vcall      mssg:"function:params:#invoke<system'Object>[0]", class:"system'dynamic'TapeFunction"
  store      sp:0

  jump       labNext

labEnd:
  peek       sp:0  

  close      []
  quit
	
labDefault:
  redirect

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  xstore     sp:0, class : "system'MethodNotFoundException"

  set        mssgconst : "new[3]"
  throw

end

procedure __closureclass

  redirect

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[index,command,len]

  save       dp:command
  store      sp:1

  len
  save       dp:len
  nsave      dp:index, 0

labNext:
  load       dp:index
  xcmp       dp:len
  jge        labEnd

  peek       sp:1
  xget
  nadd       dp:index, 1
  tst        flag:elMessage
  jeq        labNext 

  load       dp:command
  xcmp
  jne        labNext

  load       dp:index
  xget

  peek       sp:1
  xget
  load       dp:command
  or         n:FUNCTION_MESSAGE

  close      []

  xrefresh   sp:0
  xrefresh   sp:1
  jump       vt:0

labEnd:
  load       dp:command

  close      [] 
  // ; NOTE : to clear the frame variables, because of two scopes
  $clear  

  xrefresh   sp:0
  xrefresh   sp:1

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  xstore     sp:0, class : "system'MethodNotFoundException"

  set        mssgconst : "new[3]"
  throw

end


procedure __struct

  redirect

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[index,command,len]

  save       dp:command
  store      sp:1

  mlen
  cmp        n:1
  jne        labEnd

  peek       sp:1 
  len
  save       dp:len
  nsave      dp:index, 0

labNext:
  load       dp:index
  xcmp       dp:len
  jge        labEnd

  peek       sp:1
  xget
  nadd       dp:index, 1
  tst        flag:elSubject
  jeq        labNext 

  load       dp:command
  and        n: ~PROP_ARG_MASK
  xcmp
  jne        labNext

  load       dp:index
  xget

  peek       sp:1
  xget

  close      []

  xrefresh   sp:0
  xrefresh   sp:1
  quit

labEnd:
  load       dp:command

  close      []

  xrefresh   sp:0
  xrefresh   sp:1

  // ; if the message is not resolved
  open       (3),[],[tempObject:page_size]

  store      sp:1

  set        dp:tempObject
  xnewn      4, class:"system'Message"
  save
  store      sp:2

  xstore     sp:0, class : "system'MethodNotFoundException"

  set        mssgconst : "new[3]"
  throw

end

procedure __tape_eval(self, buffer, len)

  xflush     sp:0
  xflush     sp:1

  open       (4),[],[index,command,size,ptr]

  // ; alloc stack
  peek       fp:buffer
  load
  dalloc

  nsave      dp:index, 4
  nsave      dp:ptr, -1

  // while (index < len) {
labNext:
  peek       fp:len
  load       
  xcmp       dp:index
  jle        labEnd

  //command := buffer[index];
  peek       fp:buffer
  load       dp:index
  xload
  and        n:0FFh
  save       dp:command

  // index += 1;
  nadd       dp:index, 1

  // size := buffer[index];
  load       dp:index
  xload
  save       dp:size

  // index += 4;
  nadd       dp:index, 4

  // check attribute type
  load       dp:command
  cmp        n:020h
  jge        labSpecial

  // copy arguments
  set        sp:0  
  store      sp:0
  load       dp:ptr
  add        n:1
  xset       fp:0
  swap       sp:0
  load       dp:command
  dtrans

  set        dp:command
  store      sp:0
  iadd       dp:ptr, 4

  // loadClass
  exclude
  call       extern:LoadClassByBufferLA(buffer, *index, *size)
  include
  cmp        n:0
  jeq        labNotFound 

  // ; !! NOTE : we taking advantage that the operation with sp:0 does not affect the real stack
  save       sp:0
  peek       sp:0
  xrefresh   sp:0
  xrefresh   sp:1

  mov        mssg : "function:#constructor[0]"
  xadd       dp:command

  call       vt:0

  // ; store the result
  load       dp:ptr
  store      sp:0
  set        fp:0
  xassign
  nadd       dp:ptr, -1

  // i += size
  set        dp:size
  store      sp:0
  iadd       dp:index, 4

  jump       labNext

labSpecial:
  cmp        n:022h
  jeq        labTerminator

  cmp        n:020h
  jeq        labVardiatic

  peek        fp:buffer
  store       sp:3    
  set         dp:size
  store       sp:2
  set         dp:index
  store       sp:1

  xstore      sp:0, class:"system'text'UTF8Encoding"
  peek        sp:0

  mov         mssg:"toString<system'IntNumber,system'IntNumber,'$auto'system@Array#1&system@ByteNumber>[4]"
  call        mssg:"toString<system'IntNumber,system'IntNumber,'$auto'system@Array#1&system@ByteNumber>[4]", class:"system'text'UTF8Encoding"

  // ; store the result
  load       dp:ptr
  store      sp:0
  set        fp:0
  xassign
  nadd       dp:ptr, -1

  // i += size
  set        dp:size
  store      sp:0
  iadd       dp:index, 4

  jump       labNext

labTerminator:
  load       dp:ptr
  xstore     sp:0, terminator
  set        fp:0
  xassign
  nadd       dp:ptr, -1

  jump       labNext

labVardiatic:
  nsave      dp:command, 0
  load       dp:ptr

labVarLen:
  add        n:1
  set        fp:0
  xget
  nadd       dp:command, 1
  cmp        terminator
  jne        labVarLen

  // copy arguments
  set        sp:0  
  store      sp:0
  load       dp:ptr
  add        n:1
  xset       fp:0
  swap       sp:0
  load       dp:command
  dtrans

  set        dp:command
  store      sp:0
  iadd       dp:ptr, 4

  // loadClass
  exclude
  call       extern:LoadClassByBufferLA(buffer, *index, *size)
  include
  cmp        n:0
  jeq        labNotFound 

  // ; !! NOTE : we taking advantage that the operation with sp:0 does not affect the real stack
  save       sp:0
  peek       sp:0
  xrefresh   sp:0
  xrefresh   sp:1

  mov        mssg : "function:params:#constructor[1]"

  call       vt:0

  // ; store the result
  load       dp:ptr
  store      sp:0
  set        fp:0
  xassign
  nadd       dp:ptr, -1

  // i += size
  set        dp:size
  store      sp:0
  iadd       dp:index, 4

  jump       labNext

labNotFound:
  // UTF8Encoding.toString(index,size,buffer)
  peek       fp:buffer
  store      sp:3    
  set        dp:size
  store      sp:2
  set        dp:index
  store      sp:1

  xstore     sp:0, class:"system'text'UTF8Encoding"
  peek       sp:0

  mov        mssg:"toString<system'IntNumber,system'IntNumber,'$auto'system@Array#1&system@ByteNumber>[4]"
  call       mssg:"toString<system'IntNumber,system'IntNumber,'$auto'system@Array#1&system@ByteNumber>[4]", class:"system'text'UTF8Encoding"
  store      sp:1
  xstore     sp:0, class : "system'TypeLoaderException"

  set        mssgconst : "new[2]"
  throw

labEnd:
  load       dp:ptr
  add        n:1
  set        fp:0
  xget

  close      []
  quit

end

procedure __event_dispatcher

  redirect

  xflush     sp:0
  xflush     sp:1

  open       (2),[arr,tmp],[mssg, index]

  get        i:0
  store      fp:arr
  
  nsave      dp:index, 0
  save       dp:mssg

  // ; copy the call stack
  load       dp:mssg
  mlen

  cmp        n:0
  jeq        labCopyEnd

  dalloc
  set        sp:0
  alloc      i:1
  store      sp:0

  set        fp:-1
  swap       sp:0
  dtrans
  free       i:1

labCopyEnd:
  peek       fp:arr  

labNext:
  len
  xcmp       dp:index  
  jeq        labEnd

  load       dp:index
  xget
  add        n:1
  save       dp:index

  load       dp:mssg

  xrefresh   sp:0
  xrefresh   sp:1

  call       vt:0
  
  peek       fp:arr  
  jump       labNext

labEnd:
  peek       fp:arr

  close      []

end

procedure __enterCritical

  peek        sp:0

labWait:
  snop
  trylock
  jne         labWait  

end


procedure __leaveCritical

  peek        sp:0
  freelock

end

procedure __createProxy (proxy, type)

  xflush     sp:0
  xflush     sp:1

  open       (4),[]

  call       extern:InjectProxyTypeLA(proxy, type, 2, nameconst_index)
  cmp        n:-1
  jne        labSkip

  xstore     sp:0, class : "system'InvalidArgumentException"
  set        mssgconst : "new[1]"
  throw

labSkip:
  peek       fp:proxy

  close      []

end

procedure critical_exception_handler

  cmp         n:EXCEPTION_ACCESS_VIOLATION
  jeq         labAccessViolation

  cmp         n:ELENA_ERR_DIVIDE_BY_ZERO
  jeq         labDivisionByZero

  cmp         n:ELENA_ERR_OUT_OF_MEMORY
  jeq         labOutOfMemory

  cmp         n:ELENA_ERR_STACKOVERFLOW
  jeq         labStackOverflow

  xstore      sp:0, class : "system'CriticalException"
  set         mssgconst : "new[1]"
  throw

labAccessViolation:
  xstore      sp:0, class : "system'NilReferenceException"
  set         mssgconst : "new[1]"
  throw

labDivisionByZero:
  xstore      sp:0, class : "system'DivisionByZeroException"
  set         mssgconst : "new[1]"
  throw

labOutOfMemory:
  xstore      sp:0, class : "system'OutOfMemoryException"
  set         mssgconst : "new[1]"
  throw

labStackOverflow:
  xstore      sp:0, class : "system'StackOverflowException"
  set         mssgconst : "new[1]"
  throw

end

procedure default_exception_handler

  call extern:ExitLA (err_ret)

end

procedure startUpSymbols

  xflush     sp:0
  xflush     sp:1

  open       (2),[],[i,len]

  nsave      dp:i, 0

  set        marray:"$forwards'meta$startUpSymbols"

  load
  save       dp:len

labNext:
  nadd       dp:i, 1

  load       dp:i
  set        marray:"$forwards'meta$startUpSymbols"
  xget
  xcall

  load       dp:len
  xcmp       dp:i
  jne        labNext

  close      []
  quit

end

procedure func_invoker(arg)

  extopen    (2),[]

  peek       fp:arg

  get        i:0
  mov        mssg:"function:#invoke[0]" 
  call       vt:0 

  extclose   []
  quit

end

procedure thread_start(index)

  extopen     [arg1],[ptr,envptr,ex_struct:ex_struct_size]

  xloadarg    fp:index
  
  $save       dp:ptr

  // ; == enter GC critical section ==
  system      6 

  system      3

  xhook       dp:ex_struct, procedure:"system'core_routines'default_exception_handler"

  mov         env
  $save       dp:envptr
  set         dp:envptr
  store       fp:arg1

  call extern:InitThreadLA (
     *$arg1, 
     procedure:"system'core_routines'critical_exception_handler",
     *$ptr)

  system      7  
  // ; === leave GC critical section ===

  call extern:StartThreadLA (
     *$arg1, 
     procedure:"system'core_routines'func_invoker",
     *$ptr)

  unhook

  // ; == enter GC critical section ==
  snop
  system      6 

  call extern:UninitThreadLA (
     *$arg1, 
     *$ptr)

  system      7  
  // ; === leave GC critical section ===

  call extern:ExitThreadLA (0)

  extclose    []
  quit

end

symbol sta_start

  system      4

  open        [arg1],[argv, envptr,ex_struct:ex_struct_size]

  xhook       dp:ex_struct, procedure:"system'core_routines'default_exception_handler"

  mov         env
  $save       dp:envptr
  set         dp:envptr
  store       fp:arg1

  call extern:InitializeSTLA (
     *$arg1,
     symbol:"$auto'startUpSymbol",
     procedure:"system'core_routines'critical_exception_handler")

  close       []

end

symbol mta_start

  system      4

  // ; initialize TLS entry
  mov         n:0
  system      3

  open        [arg1],[envptr,ex_struct:ex_struct_size]
  
  xhook       dp:ex_struct, procedure:"system'core_routines'default_exception_handler"

  mov         env
  $save       dp:envptr
  set         dp:envptr
  store       fp:arg1

  call extern:InitializeMTLA (
     *$arg1,
     symbol:"$auto'startUpSymbol",
     procedure:"system'core_routines'critical_exception_handler")

  close       []

end

symbol vm_sta_start

  system      4

  open        [arg1],[envptr,ex_struct:ex_struct_size]
  
  xhook       dp:ex_struct, procedure:"system'core_routines'default_exception_handler"

  mov         env
  $save       dp:envptr
  set         dp:envptr
  store       fp:arg1

  call extern:InitializeVMSTLA (
     *$arg1, 
     constdump:"$elena'meta$startUpTape",
     pstr:"system'core_routines'critical_exception_handler")

  close       []

end
