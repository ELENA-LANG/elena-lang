//---------------------------------------------------------------------------
//		E L E N A   P r o j e c t:  ELENA Compiler
//               
//		This file contains ELENA Engine Derivation Tree classes
//
//                                              (C)2005-2016, by Alexei Rakov
//---------------------------------------------------------------------------

#ifndef derivationH
#define derivationH 1

#include "syntax.h"
#include "compilercommon.h"

#define EXPRESSION_EXPLICIT_MODE   1
#define EXPRESSION_MESSAGE_MODE    2

namespace _ELENA_
{

// --- DerivationWriter ---

class DerivationWriter : public _DerivationWriter
{
   SyntaxWriter _writer;

   void writeNode(Symbol symbol);

public:
   virtual void writeSymbol(Symbol symbol);
   virtual void writeTerminal(TerminalInfo& terminal);

   DerivationWriter(SyntaxTree& target)
      : _writer(target)
   {
   }
};

// --- DerivationWriter ---

class DerivationReader : public _DerivationReader
{
   // --- TemplateScope ---
   struct DerivationScope
   {
//      enum Type
//      {
//         ttNone           = 0,
//         ttFieldTemplate  = 1,
//         ttMethodTemplate = 2,
//         ttCodeTemplate   = 3,
//         ttAttrTemplate   = 4
//      };
//
//      Type         type;
//      ref_t        templateRef;  // NOTE : should be zero for template declaration
//      ref_t        reference;
//      ForwardMap   parameters;
//      ForwardMap   fields;
//      SubjectMap   subjects;
//      ident_t      sourcePath;
//
//      SNode        exprNode;     // used for code template
//      SNode        codeNode;
//      SNode        elseNode;
//      SNode        nestedNode;
//
//      SyntaxTree* autogeneratedTree;

      _CompilerScope* moduleScope;

      void raiseError(const char* message, SNode terminal)
      {
         moduleScope->raiseError(message, terminal);
      }

      bool isTypeAttribute(SNode terminal);
      ref_t mapTypeAttribute(SNode terminal);

//      void loadAttributeValues(SNode node, bool prefixMode = false);
//      void loadParameters(SNode node);
//      void loadFields(SNode node);

      void copySubject(SyntaxWriter& writer, SNode terminal);
      void copyIdentifier(SyntaxWriter& writer, SNode terminal);

      ref_t mapAttribute(SNode terminal/*, int& attrValue*/);
//      ref_t mapTemplate(SNode terminal, int prefixCounter = 0);
//      int mapIdentifier(SNode terminal);
//
//      bool generateClassName();
//
//      DerivationScope(TemplateScope* parent, ref_t attrRef)
//         : Scope(parent)
//      {
//         type = Type::ttNone;
//         templateRef = attrRef;
//         reference = 0;
//         sourcePath = NULL;
//         autogeneratedTree = parent->autogeneratedTree;
//      }
      DerivationScope(_CompilerScope* moduleScope)
      {
         this->moduleScope = moduleScope;

//         type = Type::ttNone;
//         templateRef = 0;
//         reference = 0;
//         sourcePath = NULL;
//         autogeneratedTree = NULL;
      }
   };

   enum DeclarationAttr
   {
      daNone     = 0x00,
      daType     = 0x01,
      daClass    = 0x02,
      daTemplate = 0x04,
      daField    = 0x08,
      daMethod   = 0x10, 
      daLoop     = 0x20,
      daImport   = 0x40,
      daExtern   = 0x80
   };

   SNode _root;

   void generateScopeMembers(SNode node, DerivationScope& scope);
   
   void generateMessageTree(SyntaxWriter& writer, SNode node, DerivationScope& scope/*, bool operationMode*/);
   void generateCodeTree(SyntaxWriter& writer, SNode node, DerivationScope& scope);
   void generateMethodTree(SyntaxWriter& writer, SNode node, DerivationScope& scope, SNode attributes, SyntaxTree& buffer, bool templateMode = false);
   void generateObjectTree(SyntaxWriter& writer, SNode node, DerivationScope& scope/*, int mode = 0*/);
   void generateExpressionTree(SyntaxWriter& writer, SNode node, DerivationScope& scope, int mode = EXPRESSION_EXPLICIT_MODE);
   void generateAttributes(SyntaxWriter& writer, SNode node, DerivationScope& scope, SNode attributes);
   void generateSymbolTree(SyntaxWriter& writer, SNode node, DerivationScope& scope, SNode attributes);
   void generateClassTree(SyntaxWriter& writer, SNode node, DerivationScope& scope, SNode attributes, int nested = 0);

   bool generateMethodScope(SNode node, DerivationScope& scope, SNode attributes);
   bool generateSingletonScope(SyntaxWriter& writer, SNode node, DerivationScope& scope, SNode attributes);
   bool generateDeclaration(SyntaxWriter& writer, SNode node, DerivationScope& scope, SNode attributes);
   
   void generateSyntaxTree(SyntaxWriter& writer, SNode node, _CompilerScope& scope/*, SyntaxTree& autogenerated*/);
   void generateScope(SyntaxWriter& writer, SNode node, DerivationScope& scope, SNode attributes);

   bool declareType(SNode member, DerivationScope& scope, SNode attributes);

public:
   virtual void generateSyntaxTree(SyntaxWriter& writer, _CompilerScope& scope);

   DerivationReader(SyntaxTree& tree)
   {
      _root = tree.readRoot();
   }
};

} // _ELENA_

#endif // derivationH
