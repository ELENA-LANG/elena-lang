//---------------------------------------------------------------------------
//		E L E N A   P r o j e c t:  ELENA Compiler
//
//		This file contains ELENA compiler scope class.
//
//                                              (C)2005-2018, by Alexei Rakov
//---------------------------------------------------------------------------

#ifndef compilerscopeH
#define compilerscopeH

#include "syntaxtree.h"
#include "compilercommon.h"

namespace _ELENA_
{

inline void freeident(ident_t s)
{
   if (s != NULL) {
      free((void*)s.c_str());
   }
}

//// --- SourceFileInfo ---
//struct SourceFileInfo
//{
//   _ELENA_::SyntaxTree*       tree;
//   _ELENA_::IdentifierString  path;
//   _ELENA_::IdentifierString  ns;
//   _ELENA_::IdentifierList    importedNs; // importedns contains the list of dynamically allocated strings
//
//   SourceFileInfo()
//      : importedNs(NULL, freeident)
//   {
//      tree = NULL;
//   }
//   ~SourceFileInfo()
//   {
//      _ELENA_::freeobj(tree);
//   }
//};

//typedef List<SourceFileInfo*>          SourceFileList;
//typedef Map<ref_t, SubjectList*>       AutoExtensionMap;

struct ModuleScope : _ModuleScope
{
//   AutoExtensionMap  autoExtensions;

   virtual ref_t mapAnonymous(ident_t prefix);

   // warning mapping
//      bool warnOnWeakUnresolved;
   virtual _Module* loadReferenceModule(ident_t referenceName, ref_t& reference);
   virtual _Module* loadReferenceModule(ref_t reference, ref_t& moduleReference)
   {
      return loadReferenceModule(module->resolveReference(reference), moduleReference);
   }

   virtual void importClassInfo(ClassInfo& copy, ClassInfo& target, _Module* exporter, bool headerOnly, bool inheritMode);
   
   virtual ref_t loadClassInfo(ClassInfo& info, ident_t vmtName, bool headerOnly = false);
   virtual ref_t loadClassInfo(ClassInfo& info, ref_t reference, bool headerOnly = false)
   {
      return loadClassInfo(info, module->resolveReference(reference), headerOnly);
   }
   virtual ref_t loadSymbolExpressionInfo(SymbolExpressionInfo& info, ident_t symbolName);

//   //   ref_t mapIdentifier(ident_t referenceName, bool existing = false);
   virtual ref_t mapFullReference(ident_t referenceName, bool existing = false);
//   ///*virtual */ref_t mapNewTerminal(SNode terminal, bool privateOne);
   virtual ref_t mapTemplateClass(ident_t ns, ident_t templateName, bool& alreadyDeclared);
   virtual ref_t mapNewIdentifier(ident_t ns, ident_t identifier, bool privateOne);

   virtual _Memory* mapSection(ref_t reference, bool existing)
   {
      ref_t mask = reference & mskAnyRef;
   
      ident_t referenceName = module->resolveReference(reference & ~mskAnyRef);
      if (isTemplateWeakReference(referenceName)) {
         return module->mapSection(module->mapReference(resolveWeakTemplateReference(referenceName + TEMPLATE_PREFIX_NS_LEN)) | mask, existing);
      }
      else return module->mapSection(reference, existing);
   }
   
   ident_t resolveWeakTemplateReference(ident_t referenceName);

//   void saveIncludedModule(_Module* extModule);
   //void saveListMember(ident_t sectionName, ident_t memberName);

   virtual ref_t resolveImplicitIdentifier(ident_t ns, ident_t identifier, bool referenceOne, IdentifierList* importedNs);

   virtual ident_t resolveFullName(ref_t reference)
   {
      ident_t referenceName = module->resolveReference(reference & ~mskAnyRef);
      if (isTemplateWeakReference(referenceName)) {
         return project->resolveForward(referenceName + TEMPLATE_PREFIX_NS_LEN);
      }
      else return referenceName;
   }   
   virtual ident_t resolveFullName(ident_t referenceName)
   {
      if (isTemplateWeakReference(referenceName)) {
         return project->resolveForward(referenceName + TEMPLATE_PREFIX_NS_LEN);
      }
      else return referenceName;
   }

//   virtual ref_t resolveClosure(_Compiler& compiler, ref_t closureMessage, ref_t outputRef, ExtensionMap* extensionsToExport);

   virtual ref_t generateTemplate(/*_Compiler& compiler, */ref_t reference, List<ref_t>& parameters/*, ExtensionMap* extensionsToExport*/);

   virtual void saveAttribute(ident_t typeName, ref_t classReference);

   //virtual void declareNamespace(ident_t name);
//   virtual bool includeNamespace(IdentifierList& importedNs, ident_t name, bool& duplicateInclusion);
//
//   virtual SubjectList* getAutogerenatedExtensions(ref_t attr)
//   {
//      return autoExtensions.get(attr);
//   }
//
//   void loadAutogeneratedExtension(_Module* module);
//   virtual void saveAutogerenatedExtension(ref_t attr, ref_t extension);

   void compile(_Compiler& compiler, SyntaxTree& derivationTree/*, ExtensionMap* extensionsToExport*/);

   ModuleScope(_ProjectManager* project)
//      : autoExtensions(NULL, freeobj)
   {
      this->project = project;

   //   warnOnWeakUnresolved = project->WarnOnWeakUnresolved();
   }
};

} // _ELENA_

#endif // compilerscopeH
