{{language|Smalltalk
|exec=bytecode
|strength=strong
|safety=safe
|express=implicit
|checking=dynamic
|parampass=value
|gc=yes
|LCT=yes
|bnf=http://github.com/aquasync/ruby-ometa/blob/60deea23abe7eb07d200233dde4213d74041b81f/smalltalk.syntax}}
{{language programming paradigm|Object-oriented}}
{{language programming paradigm|reflective}}
{{language programming paradigm|Dynamic}}
'''Smalltalk-80''' is an [[object-oriented programming|object-oriented]], dynamically typed, [[reflective programming]] language. It was designed and created in part for educational use, more so for Constructivist teaching, at Xerox PARC by Alan Kay, Dan Ingalls, Ted Kaehler, Adele Goldberg, and others during the 1970s, influenced by Sketchpad and Simula.

The language was generally released as Smalltalk-80 and has been widely used since. Smalltalk-like languages are in continuing active development, and has gathered a loyal community of users around it.

'''Smalltalk-80''' is a fully reflective system, implemented in itself. Smalltalk-80 provides both structural and computational reflection. Smalltalk is a structurally reflective system whose structure is defined by Smalltalk-80 objects. The classes and methods that define the system are themselves objects and fully part of the system that they help define. The Smalltalk compiler compiles textual source code into method objects, typically instances of <code>CompiledMethod</code>. These get added to classes by storing them in a class's method dictionary. The part of the class hierarchy that defines classes can add new classes to the system. The system is extended by running Smalltalk-80 code that creates or redefines classes and methods. In this way a Smalltalk-80 system is a "living" system, carrying around the ability to extend itself at run-time.

==Implementations==
Over time, various implementations ("dialects") of Smalltalk have appeared, some of which target different audiences and/or focus on particular applications. Their internal implementation (evaluation mechanism) may also differ radically, from bytecode interpretation, just-in-time compilation, dynamic optimizing recompilation to cross-language translators (Smalltalk-to-C, Smalltalk-to-JavaScript, Smalltalk-to-Java).

==Spirit==
Smalltalk consist of both the programming language and a more or less standardized library of classes. Most Smalltalks also include a sophisticated IDE, which supports editing, compiling, refactoring, debugging, tools, source code revisioning and packaging/deployment. With a few exceptions, working in a traditional editor (vi, emacs) or general purpose IDE (eclipse) is usually not recommended, as these cannot make use of all the reflective and dynamic coding features and will make the programmer less productive. For example, typical Smalltalk debuggers allow for code to be changed while the program is running (or halted at a breakpoint), allowing for a "programming in the debugger" style of coding. Code is usually developed and tested incrementally, with breakpoints on unimplemented parts, which are filled as encountered. This makes Smalltalk a perfect environment for rapid prototyping and experimental development. 

Smalltalk environments are open - almost every aspect of the language and IDE can be changed, enhanced and customized. This includes object representation, metaclass and reflection facilities, language syntax, exception handling and the IDE itself. For this reason, Smalltalk has traditionally been a testbed for new language features, mechanisms and patterns.

Smalltalk is a very high level language, which almost completely hides any underlying machine representation. Implementation details such as integer size, pointer size, byte order etc. are invisible. The numeric tower is highly polymorphic, allowing for transparent use of arbitrary large integers, fractions, floats, complex numbers etc.

Smalltalk is a very late bound language. Object types, classes, references etc. are resolved at execution time, and can be dynamically changed.

==Language Syntax==
Smalltalk has a very simple and highly orthogonal syntax, which is based exclusively on message sending (aka pure virtual function calling in C-parlance). The language syntax and semantic only consists of literal (compile-time) constants, variable bindings, message sends and block closures (lambda expression objects). Control flow, loop constructs, exception handling etc. are defined as messages to booleans, blocks or by passing blocks as arguments. This makes it trivial and common practice to add new control constructs.

=== Grammar ===
... to be added ... (for now follow the link at the right...)

== Language Semantic ==

=== Variables and Scope ===
Variables are used to name objects. Actually they are bindings of a name to an object. Objects can only be passed and used by reference, and access to an object's internals is not possible from outside the object's own method implementation, although most classes inherit from Object, which provides some reflection protocol to access instance variables or to query for the class. However, such inherited reflection mechanisms could be overwritten in a class or a class could not inherit from Object, to prevent even access from debuggers and inspectors.

Smalltalk is lexically scoped, and outer variable bindings are closed over when a block (=lambda closure) is created.

A rich scoping hierarchy exists, which consists of:
* inner block locals
* inner block arguments
* outer block locals
* outer block arguments
* method locals
* method arguments
* instance variable slots
* inherited instance variable slots
* class variables (static, shared with subclasses; visible in the class-hierarchy only)
* class instance variables (per-class-instance; private to the class)
* pool variables (for constant pools; must be explicitly "imported" to be seen)
* namespaces / globals (for classes to be known by name)

=== Objects ===
In Smalltalk, every object is an instance of some class. Objects are only be referred to by reference. Everything is an object, including integers, booleans, nil (the UndefinedObject), classes, stack frames (continuations), exception handlers and code (block closures/lambda closures and methods). There are no builtin primitive types, which are not part of the class hierarchy, or which cannot be changed/enhanced by the user.

=== Message Sending ===   
Message sends are dynamically resolved, by letting the receiver of the message determine the method (aka code to run). The message consist of a selector (= name of the message) and optional arguments. The message syntax as:
<lang smalltalk>receiver selector</lang>
a unary message, without arguments.

<lang smalltalk>receiver part1: arg1 part2: arg2 ... partN: argN</lang>
a keyword message; the selector consists of the concatenation of the keyword parts: 'part1:part2:...partN:'.

<lang smalltalk>receiver op arg</lang>
a so called ''binary message''. The selector 'op' consists of one or more special characters, such as '+', -', '@' etc.
These are actually syntactic sugar, especially to make arithmetic look more familiar (i.e. instead of "rcvr add: foo" we can write "rcvr + foo").

The precedence rules are unary > binary > keyword, thus 
<lang smalltalk>a foo: b bar + c baz</lang> is equivalent to <lang smalltalk>a foo:( (b bar) + (c baz) )</lang>

As messages have no semantic meaning to the compiler (especially, the '+', '*' and other binary messages), the usual precedence rules for arithmetic expressions are not present in Smalltalk. Thus, complex expressions consisting of multiple binary messages usually need to be parenthesized. 

Message lookup is done by traversing the superclass chain, looking for a class providing an implementation (method) for the messages selector. The standard defines single inheritance, with a lookup based on the receiver's class only. However, some Smalltalk implementations allow for that lookup to be redefined and provide more sophisticated mechanisms (selector namespaces, lookup objects, lookup based on argument types etc.). 

If no implementation is found (i.e. no class along the superclass chain provides a corresponding method), the original selector and arguments are packed into a container and a doesNotUnderstand: message is sent instead. This is used for error handling, but can also be used for message forwarding (proxies), delegation or dynamic creation of new code. The default implementation of doesNotUnderstand: raises an exception, which can be cought and handled by the program.

=== Metaclass Hierarchy ===
Classes themself are objects and as such instances of some Metaclass. As classes define and provide the protocol (=set of methods) for their instances, metaclasses define and provide the protocol for their instances, the corresponding class. Every class has its own metaclass and as such can implement new class-side messages. Typically, instance creation and utility code is found on the class side. Most Smalltalk dialects allow for the metaclass to specify and return the type of compiler or other tools to be used when code is to be installed. This allows for DSLs or other programming language syntax to be implemented seamlessly by defining a metaclass which returns a compiler for a non-Smalltalk. Typical examples for this are parser generators (tgen, ometa, petite parser), data representation specs (asn1, xml etc.) and languages (smallRuby, graphical languages in squeak etc.)   

Being objects, classes and metaclasses can be created dynamically, by sending a #subclass:... message to another class, or my instantiating a new metaclass.

=== Exception Handling ===
Smalltalk protects itself completely from any invalid memory references, null-pointer, array bounds or unimplemented message situations, by raising a corresponding exception which can be cought by the program. An unhandled exception leads to the evaluation of a default handler, which usually opens a symbolic debugger, which is always part of the Smalltalk environment. Deployed end-user and production systems usually redefine this handler to show a warning, end the program or dump the state of the system.

In contrast to most other exception handling systems, Smalltalk exceptions are both restartable and proceedable. The exception handler is evaluated with the calling chain of continuations (stack frames) still being active and alive. The handler is free to repair the situation and proceed. Proceedability allows for queries and notifications to be implemented easily using exceptions; for example, a compiler's warnings or error correction queries can be implemented this way, without a need to pass in logger objects or other state. Also situations like missing files (OpenError) can be resolved in the handler, by opening a dialog, asking the user for a replacement and proceed. 

The exception framework is implemented as part of the class library, and open for change and enhancement.

== Examples ==
As smalltalk code seems to be hard to read for programmers with a C background, some examples are provided below.
=== Literals ===
<lang smalltalk>
"a comment - everything in between double quotes"

"/ an end-of-line comment (dialect specific)

true false "the two Boolean singleton objects"

nil "the UndefinedObject singleton object"

1234 "integer constant; an instance of Integer"

16rFF00 "integer constant, base 16"

2r101010 "integer constant, base 2"

1.234 "float constant; an instance of Float"

(1/7) "fraction constant; an instance of Fraction"

123s3 "fixed point constant with precision (somewhat dialect specific)

'hello' "string constant; an instance of String"

'√∂√§√º „Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå' "string constnt unicode is supported by most implementations"

#'foo' "symbol constant; similar to symbols in lisp, two symbols are identical if they are equal"

#(1 true $a 16rFF 1.0 (10 20)) "array literal constant; the last element being another array; an instance of Array"

#[ 10 20 2r1000 16rFE ] "byte-array literal constant; an instance of ByteArray"

$a "character constant"

[ ... some code ... ] "a block literal; an instance of BlockClosure (dialect specific); the object represents the piece of code which can be passed around and evaluated later (a lambda closure)"

[:a1 ... :aN | ... some code ...] "a block literal with arguments."
</lang>

===Special "builtin" Pseudo Veriables===
<lang smalltalk>
self "refers to the current receiver"

super "for super sends"

thisContext "refers to the current context (stack frame/continuation) as an object"
</lang>

===Message Sends===
<lang smalltalk>
1000 factorial "send the 'factorial' message to the integer receiver"

a factorial even "send the 'factorial' message to whatever "a" refers to, then send 'even' to whatever that returned"

a + 1 "send a '+' message, passing the argument '1' to whatever a refers to"

(a + 1) squared "send '+' to a, then send 'squared' to whatever we get from it"

a , b "send the (binary) ',' message, which does collection-concatenation (arrays, strings, etc)

arr at:1 put:'foo' "send the 'at:put:' message to 'arr', passing two arguments, the integer '1' and a string"

a > b ifTrue: [ a print ] "send the 'ifTrue:' message to whatever 'a > b' returned (a boolean, usually), passing a block closure as argument. The implementation of boolean will either evaluate or not evaluate the passed block's code"

a > b ifTrue: [ a ] ifFalse: [b] "send 'ifTrue:ifFalse:' to the object returned by 'a > b', passing two block closures as arguments. The 'ifTrue:ifFalse:' method will evaluate one of them and return that block's return value as its own return value"

b := [ ... somCode... ].
...
b value "evaluate the block's code"
</lang>

=== Other ===
<lang smalltalk>
expr1 . expr2 "statements within a method or block are separated by a fullstop."

foo := bar "assignment; let foo refer to the object to which bar refers to (at that particular point in time)"

^ a + 1 "return; the value of the 'a+1' message send is returned as the value of the current method invocation."

'hello' print. 'world' print "statements are separated by a period; just like in english"

|a b c| "local variables; introduces 'a', 'b' and 'c' in the current scope (let-like local bindings)"

r msg1; msg2 "so called cascade; first send msg1 to r, ignoring the return value, then send msg2. 
                       Value of expression is result from last message. Syntactic sugar for r msg1. r msg2 but an expression, not a statement" 
</lang>

=== Class Definition ===
Classes are not defined by syntactic constructs, but by sending a message to some class (to create a subclass), a metaclass (to create an instance) or to a namespace (to create a class and install it). The details vary slightly among dialects, but usually wrappers/forwarders are provided or easily added if code is to be ported and any is missing in the target system.
<lang smalltalk>
someClass 
    subClass: #'nameOfNewClass'
    instanceVariableNames: '...list of private slots...'
    classVariableNames: '...list of class variables...'
    poolDictionaries: '..list of imported pool bindings...'
    category: 'for documentation only'.
</lang>
Classes can be anonymous, in most systems, you can "Class new new" to create a new anonymous class and an instance of it (but be aware, that the class should contain enough state to properly specify their instance's layout, so usually more info is needed (number and names of instance variables, inheritance etc.). Otherwise some tools (Inspector) may fail to reflect on it.

=== Control Structures ===
As mentioned above, these are defined as messages and their implementation is found in the corresponding receiver classes. The following is only a tiny subset - there are virtually hundreds of uses of blocks for control structures in the system.
Typical are:
<lang smalltalk>
boolean ifTrue: [ block providing value if boolean is true ]

boolean ifFalse: [ block providing value if boolean is false ]

boolean ifTrue: [ value if boolean is true ] ifFalse: [ value if boolean is false ]

[ block for condition ] whileTrue: [ block to be looped over ]

n timesRepeat:  [ block to be looped over ]

start to: stop do: [:i | block to be looped over with index ]

collection do: [:el | block to be evaluated for each element ]
</lang>

=== Exception Handling ===
Originally, Smalltalk used an instance based exception handling scheme, where instances of Signal where created and raised. Now, all implementations have moved to class based exceptions, where the raised exception is a subclass of Exception. As instance based exception handling is still useful in some situations (very lightweight, no need to create a class), some dialects continue to support both.

Smalltalk supports proceedable exceptions.

<lang smalltalk>
[ try block to be evaluated ] on: exception do:[:ex | handler ]
</lang>
the 'ex' argument to the hander provides detail information (where and why) and also allows control of how to proceed out of the handler (ex proceed, ex return, ex restart, ex reject).
The handler basically has the following options:
* ex return - return out of the try block
* ex restart - restart the try block
* ex reject - handler cannot handle; rethrow the exception for an outer handler
* ex proceedWith: value - proceed after where the exception was raised (after a repair)
Exceptions may be specified to be nonProceedable, to protect code from proceeding handlers, where proceeding is not possible.
Exceptions form a hierarchy, so a handler will also catch any derived exceptions. If an exception is unhandled, the original exception info is packed up and an UnhandledException is raised. Thus (similar to the handling of doesNotUnderstand:). The default handler for UnhandledException opens a debugger for the misbehaving thread (while usually other threads continue to operate as usual).

Handlers can also be defined to handle a collection of non-related exceptions, by creating an exceptionSet:
 <lang smalltalk>
[ try block to be evaluated ] on: ZeroDivide, DomainError do:[:ex | handler ]
</lang>
finally, many dialects provide syntactic sugar for common situations:
<lang smalltalk>
exception catch: [ action ]  - to return out of the action, without any particular handler action

exception ignoreIn: [ action ] - to ignore the exception and proceed (for example: a UserInterruptSignal, as generated by the CTRL-C key)
</lang>

=== Unwinding ===
Ensure blocks to make sure that cleanup is performed correctly even in exception situations are defined as:
<lang smalltalk>
[ action to be performed ] ensure: [ action to cleanup] - will cleanup in any case (i.e. both in normal and in unwind situations)

[ action to be performed ] ifCurtailed: [ action to cleanup] - will cleanup only in unwind situations
</lang>

=== Multithreading ===
New threads are started by sending 'fork' to a block; this will create a process instance which executes the block's code in a separate thread (within the same address space):
<lang smalltalk>
[ do something ] fork.

[ do something ] forkAt: priorityLevel
</lang>
Notice that these are technically threads, not "unix processes". They execute in the same address (or object-) space. 
They are named "Process" and created with "fork" in Smalltalk for historic reasons.

The scheduling behavior is not standard among dialects/implementations. Some only manual switch by explicit yield, most provide sctrict priority based scheduling, and some even provide preemtive timeslicing, and dynamic priorities. The details may also depend on the underlying operating system.

== Implementation ==
Most Smalltalk implementations are based on a bytecode execution engine. Bytecode is emitted and stored in method objects by a compiler which is part of both the development and runtime environment (in contrast to external tools, like javac). Thus new methods can be generated and installed dynamically by reading scripts or a generator. Bytecodes are operations for a virtual stack based machine, which is either interpreted by an interpreter (part of the runtime system), or dynamically compiled to machine code (JITTER). Bytecode is not standardized and usually not compatible among dialects.

Some implementations support source-to-source compilation to C, JavaScript or Java. These may or may not show some limitations in the support for dynamic changes at execution time. Typically, the full dynamic bytecode is used for development, followed by a compilation phase for deployment/packaging.

All Smalltalks use and depend on garbage collection for automatic reclamation of unused objects, and most implementations use modern algorithms such as generation scavenging, incremental mark&sweep and finalization support. Imprecise conservative collectors are typically not used. Reference counting was abandoned in the 70s.

As message send performance is critical in Smalltalk, highly tuned cache mechanisms have been invented and are used: inline caches, polymorph inline caches, dynamic recompilation based on receiver and/or argument types etc.
Also block (aka lambda) creation and evaluation, especially the treatment of closed over variables has been in the focus of implementors. Algorithms similar to those found in sophisticated Lisp systems such as lambda lifting, inlining, stack allocation and heap migration etc. are also used in Smalltalk.

== Influences ==
Smalltalk syntax is meant to be read like english sentences. 

The syntax is very compact and almost every semantic feature is implemented via a messsage send to some receiver object, instead of being a syntactic language feature of the compiler. As such, changes, fixes and enhancements of such features can be made easily. It has and is therefore often used as a testbed for research,

Smalltalk's symbols correspond to Lisp symbols, blocks are syntactic sugar for lambda closures. 

ObjectiveC's message send, syntax and keyword format is a direct subset of the corresponding Smalltalk message send syntax. Also the semantic of its classes and instances are similar. However, the reflection and metaclass facilities are a small subset.

Java's container and stream class hierarchy has similarities to Smalltalk collection classes. MVC as used in many toolkits has been in Smalltalk for a long time.

Self a descendent of Smalltalk, uses a similar syntax, blocks and exception facilities, but adds instance based inheritance, dynamic slots and mirrors.

Slate and Newspeak use similar syntax and message send semantics.

Newspeak generalizes the scoping to include nested classes, namespace instantiation and abstracts variable access. 

JavaScript's functions are a syntactic different but semantically equal to Smalltalk's blocks, including scoping rules (but lack the capability of returning from their containing function).

==Implementations==

* Amber Smalltalk
* Dolphin Smalltalk; (still actively developed?)
* GNU Smalltalk; open source
* Pharo; open source, mostly compatible to Squeak
* S#
* Smalltalk/X; free for private and commercial use
* Smalltalk-MT; (still actively developed?)
* Squeak; open source
* VisualAge Smalltalk (Instantiations; formerly known as IBM Smalltalk); free for private use
* VisualWorks (Cincom) Smalltalk; free for private use

==Citations==
* [[wp:SmallTalk|Wikipedia:Smalltalk]]





# 1. Introduction

ELENA is a general-purpose, object-oriented, polymorphic language with late binding. It features message dispatching/manipulation, dynamic object mutation, a script engine / interpreter and group object support.

1.1. Namespaces
---

Any  ELENA program or library consists of modules ( files with .NL extension ) containing classes and symbols. Every member of the module is referred by its fully qualified name which consists of namespace and a proper name separated by an apostrophe. The namespace itself may contain sub elements separated by apostrophes.

All source files (files  with .L extension) located in the same folder are compiled into the corresponding module. A project file ( a file with .PRJ extension ) defines the root namespace and the output type (stand-alone executable, VM executable or a library). The project may produce several modules if it contains the files located in sub folders (the new module namespace consists of the root one and the folder relative path is split by apostrophes).

1.2. Messaging
---

The main way to interact with objects in ELENA is sending a message. The message 
name  is structured and consists of a verb, a signature and a parameter counter. 
The  verb  defines a message action, for example *eval[uate]*, *add*, *set*, *get*, *run*, 
*seek*  and  so on. There are only limited set of possible verbs. The signature is 
user defined and describes the message parameters. It can be used to define some 
custom  action  as well (e.g. *writeLine*, which in fact is *eval&writeLine(1)*). If 
the signature is not provided the message is considered to be generic and can be
qualified (for example by dispatching).

If the object wants to handle the message it has to contain the method with the same name. If no method mapping was found the flow is considered to be broken and the control goes to the next alternative flow (exception handler) or the program is stopped.

The simple code to send a message looks like this:

    console write:"Hello World".

Note: *write* is a generic message; a literal constant is a parameter. A dot is a statement terminator.

Several messages can be send in one statement, the parameter itself may be result of object interactions as well:

    console write "2 + 2 =" write:(2 add:2).

We could use operators to have the shorter code:

    console << "2+2=" << 2 + 2.

Note: In most cases *"<<"* is a synonym to *write* and *"+"* to *add*.

Several parameters can be passed in the message as well:

    console write:"Hello World" &paddingLeft:10 &with:#32

Ampersand is used to indicate that the signature has several arguments (subjects). The actual 
message name is *write&paddingLeft&with(2)*.

The generic message can have several parameters as well:

    console writeLine:"a+b=":(a + b).


1.3. Classes, Symbols, Nested classes and Closures
---

ELENA is an object-oriented language. To create a program we have	 to declare new classes and symbols.

A class encapsulates data (fields) with code (methods) to access it. In most cases it is not possible
to get a direct access to the class content. Usually the field refers to another class and so on
until we reach "primitive" ones which content are considered as raw data (e.g. numeric or literal values).

Classes form the inheritance tree. There is the common super class - system'Object.
ELENA does not support multiple inheritance, though it is possible to inherit the code using a dispatch handler 
(mixins / group objects). When the parent is not provided the class inherits directly system'Object 
(the super class).

A class instance can be created with the help of the special methods - constructors. A constructor
is used mostly to initialize the class fields. There are special types of classes which do not have constructors
and can be used directly (nested classes, extensions, closures). A class itself is considered as a stateless
object.

    class BaseClass
    {
      object theField1.
      object theField2.
      
      field1 = theField1.
    
      field2 = theField2.
    
    }
    
    class DerivedClass :: BaseClass
    {
      constructor new &field1:object1 &field2:object2
      [  
         theField1 := object1.
         theField2 := object2.
      ]
    
      add &field1:object1 &field2:object2
         = MyClass new &field1:(theField1 + object1) &field2:(theField2 + object1).
    }
    
To create a class instance we have to send a message (usually new) to its class.

    var anObject := DerivedClass new &field1:1 &field2:1.

A symbol is a named expression and can be used to declare initialized objects, constants, reusable expressions
and so on.

    const N = 1. 
 
    symbol TheClass = DerivedClass new &field1:N &field2:N.

A static symbol is the named expression which state is preserved. There could be only one instance of static symbol.

    static SingletonClass = DerivedClass new &field1:0 &field2:0.

Nested classes can be declared in the code and used directly.

    class ClassHelper =
    {
       sumOf:object1:object2
          = anObject1 add &field1:object1 &field2:object2.
    }.
    
    ...
    
    var aSum := ClassHelper sumOf:anObject1:anObject2.

Closure is a special case of the nested class and consists of the code enclosed into square brackets
(with optional parameter declaration)

    str run &each:
       ch [ console write:ch. ].


1.4. Code blocks
---

ELENA code block consists of one or more declarations and statements. The block is enclosed in square brackets and may contain nested sub code blocks. The statement terminator is a dot.

    control run &int:0 &int:MAX &every: (&int:i)
    [
        pi += -1.0r power &int:i / (2*i+1) * 4.
    ].

    console writeLine:pi.
    console writeLine:"Time elapsed in msec:":(aDiff milliseconds).

When a method should return a result (other than $self) return statement is used. It should be the last statement in the block.

    [
        ...
    
        ^ aRetVal / anArray length.
    ]

If the code block contains only return statement the simplified syntax can be used:

    Number = convertor toReal:theValue.    

or there is an alternative block expression

    [ convertor toReal:theValue ]

Note: it should not end with the terminator symbol

It is possible to declare the block variable and assigns the value to it. The variable name must be unique within the code block scope.

    var aRetVal := Integer new:0.


1.5. Conditional branching
--
Conditional branching is implemented with a help of special Boolean symbols (systemítrue and systemífalse). All conditional operations should return these symbols as a result.

There are three branching methods : _if[1]_ , _if[2]_, _ifnot[1]_

    (m == 0) if:
    [
       r append:(n + 1).
    ]
    : [
       r append:(m + n).
    ].

This expression can be written using special operators

    (m == 0) 
      ? [ r append:(n + 1). ]
      ! [ r append:(m + n). ].

We could omit true or else part

    (m == 0) 
       ! [ m / n ].

Boolean symbols supports basic logical operations (AND, OR, XOR and NOT), so several conditions can be checked

    ((aChar >= 48) and:(aChar < 58))
    ? [
        theToken += aChar.
    ]
    ! [
       Exception new:"Invalid expression" raise.
    ]

Note that in this case both condition will be evaluated even if the first one is false. If we want to use short-circuit evaluation, lazy expression should be used:

    ((x >= 0)and:[ array@x != 0]) ?
    [
        ...
    ]

A switch statement can be implemented using => operator

    ^ aBulls =>
         -1 ? [ console writeLine:"Not a valid guess.". ^ true. ]
          4 ? [ 
                  console writeLine:"Congratulations! You have won!". 
                  ^ false. 
              ]
            ! [
                 theAttempt += 1.
                 
                 console writeLine:
                      "Your Score is " : aBulls 
                      : " bulls and " : aCows : " cows".
                 
                 ^ true.
            ].

1.6. Hello world program
---

To write a simple console application, we have to declare the program main symbol - an object handling _eval[0]_ message. The simplest way is to declare a nested class:

    program =
    {
        eval
        [
            system'console writeLine:"Hello World" .
        ] 
    }.

A nested class containing only one _eval_ method can be declared as a closure:

    program =
    [
        system'console writeLine:"Hello World" .
    ].

Finally we may import system namespace:

    #import system.

    program =
    [
        console writeLine:"Hello World" .
    ].

# 2. Interactions

2.1. Message
---

2.2. Sending
---

2.3. Receiving
---

2.4. Manipulating
---

2.5. Exceptions handling
---


# 3. Lexical Structure
--

An ELENA module consists of one or more source files. A source file is an ordered sequence of Unicode characters (usually encoded with the UTF-8 encoding).

There are several sequences of input elements: white space, comments and tokens. The tokens are the identifiers, keywords, literals, operators 
and punctuators.

The raw input stream of Unicode characters is reduced by ELENA DFA into a sequence of <nowiki>&lt;</nowiki>input elements<nowiki>&gt;</nowiki>. 

	<input> :
			{ <input element> }*
		
	<input element> :
			<white space>
			<comment>
			<token>
			
	<token> :
			<identifier>
			<full identifier>
			<local identifier>
			<keyword>
			<literal>
			<operator-or-punctuator>

Of these basic elements, only tokens are significant in the syntactic grammar of an ELENA program.

2.1. White space
--
ELENA White space are a space, a horizontal tab and line terminators. They are used to separate tokens.

	<white space> :
		SP (space)
		HT (horizontal tab)
		CR (return)
		LF (new line)
	
2.2. Comments	
--

ELENA uses c++-style comments:

   /* block comment */

   // end-of-line comment

	<comment> :
		<block comment>
		<end-of-line comment>
		
	<block comment> :
		'/' '*' <block comment tail>
		
	<end-of-line comment> :	
		'/' '/' { <not line terminator> }*
		
	<block comment tail> :
		'*' <block comment star tail> 
                <not star> <block comment tail>
		
	<block comment star tail> :
		'/' 
                '*' <block comment star tail> 
                <neither star nor slash> <block comment tail>
		
	<not star> :
		any Unicode character except '*'
		
	<neither star nor slash> :
		any Unicode character except '*' and '/'

	<not line terminator> :
		any symbol except LR and CF

ELENA comments do not nest. Comments do not occur inside string literals

2.3. Identifiers
--

An identifier is a sequence of letters, underscore and digits starting with letter or underscore. An identifier length is restricted 
in the current compiler design (maximal 255 characters)

	<identifier> :
		<letter> { <letter or digit> }*
		
	<letter> :
		Unicode character except white space, punctuator or operator
		'_'
		
	<letter or digit> :
		<letter>
		Digit 0-9
		
ELENA identifiers are case sensitive.

2.4. Full identifiers
--

A full identifier is a sequence of identifiers separated with "'" characters. It consists of a namespace and a proper name.  
A full identifier length is restricted in the current compiler design (maximal 255 characters)

	<full identifier> :
		[ <name space> ]? "'" <identifier>		
		
	<name space> :
		<identifier> [ "'" { <identifier> } ]*
		
2.5. Local identifiers
--

A local identifier is a sequence of letters, underscore and digits starting with '$' character. A local identifier length is restricted 
in the current compiler design (maximal 255 characters)

	<local identifier> :
		'$' <identifier>
		
2.6. Keywords
--

A keyword is a sequence of letters starting with '#' character. Currently only following keywords are used though others reserved for future use: 
<nowiki>#class, #symbol, #static, #field, #method, #constructor, #var, #loop, #define, #type, #throw, #break.</nowiki> 
Keywords can be placed only in the beginning 
of the statement.
	
	<local identifier> :
		'#' { <letter> }+
	
	<letter> :
		Unicode character

2.7. Literals
---

A literal is the source code representation of a value.

	<literal> :
		<integer>
		<float>
		<string>
		
2.7.1. Integer literals
----

An integer literal may be expressed in decimal (base 10) or hexadecimal(16).

	<integer> :
		<decimal integer>
		<hexadecimal integer>
		
	<decimal integer> :
		[ <sign> ] { <digit> }+

	<sign> :
		"+"
		"-"
		
	<digit> :
		digit 0-9
		
	<hexadecimal integer> :
		<digit> <digit or hexdigit>* 'h'
		
	<digit or hexdigit> :
		<digit>		
		one of following character - a b c d e f A B C D E F
		
2.7.2. Floating-point literals
----

A floating-point literal has the following parts: a whole-number part, a decimal point, and fractional part, an exponent.  The exponent, if present, 
is indicated by the Unicide letter 'e' or 'E' followed by an optionally signed integer.

At least one digit, in either the whole number or the fraction part, and a decimal point or an exponent are required. All other parts are optional.

	<float> :
		{ <digit> }* '.' { <digit> }* [ <exponent> ] 'r'
		{ <digit> }+ <exponent> 'r'
		
	<digit> :
		digit 0-9

	<exponent> :
		<exponent sign> <integer>
		
	<exponent sign> :
		either 'E' or 'e'
		
	<integer> :
		<sign>? <digit>+
		
	<sign> :
		"+"
		"-"

Real literals are represented with 64-bit double-precision binary floating-point formats.

2.7.3. String literal
----

A string literal consists of zero or more characters enclosed in double quotes. Characters may be represented by escape sequences.

	<string> : 
		'"' <string tail> '"'
		
	<string tail> :
		<string character> { <string tail> }*
		<escape sequence>  { <string tail> }*
		'%' '%' { <string tail> }*
		'"' '"' { <string tail> }*
		
	<string character> :
		any character except CR or LF or '"'
		
2.7.4. String literal escape sequences
----

The string literal escape sequences allow for the representation of some non-graphic character as well as the double quote and percent character.

	<escape sequence> :
		'%' <decimal escape>
		
	<decimal escape> :
		{ <digit> }+
		<alert>
		<backspace>
		<horizontal tab>
		<carriage return>
		<new line>
		
	<digit> :
		digit 0-9
    
	<alert> :
		'a'
    
	<backspace> :
		'b'
    
	<horizontal tab> :
		't'
    
	<carriage return> :
		'r'
    
	<new line> :
		'n'
		
2.8. Operators and punctuators
---

There are several kinds of operators and punctuators. Operators are short-cut form of messages taking one operand. Punctuators are for grouping and separating. 

	<operator-or-punctuator> : one of
		'(', ')', '[', ']', '<', '>', '{', '}', 
		'.', ',', '|', ':', '::', '=', '=>', 
		'+', '-', '*', '/', '+=', '-=', '*=', '/=', 
		'||', '&&', '^^', '<<', '>>', ':='

