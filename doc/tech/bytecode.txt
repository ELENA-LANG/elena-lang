
ELENA byte codes (or ecodes)
============================

 ELENA virtual machine registers:

   f(p)   - frame pointer  (positive values - pointing to the current frame, 
                            negative - to the previous frame)
   s(p)   - stack pointer  (only positive)

   a(cc)  - accumulator

   m(cc)  - message accumulator

   b(ase) -  self

   d(ex)  - index

 Legend:
   a   - accumulator
   b   - self
   d   - index
   r   - reference
   i   - index  
   m   - message 
   n   - int
   l   - long
   rl  - real
   ws  - wideliteral

 
 stack commands:
 ---------------
 pop                        - sp--; 
                              should not affect the command result;
                              should not affect the message prefix;
                              x86: should not change EAX
 
 popa                       - acc <= [sp] ; sp--
 
 popai i                    - [acc::i] <= [sp] ; sp--;
                              use GC reference bit masks

 popb                       - restore the last self variable;
 
 popbi i                    - [self::i] <= [sp] ; sp-- ;
                               use GC reference bit masks
 
 popfi i                    - [fp+i] <= [sp] ; sp--

 popi n                     - sp-=i; 
                              should not affect the command result;
                              should not affect the message prefix;
                              x86: should not change EAX
 
 popm                       - mcc <= [sp] ; sp--
 
 popsi i                    - [sp+i] <= [sp] ; sp--

 pusha                      - acc => [sp+1] ; sp++                  
    
 pushai i                   - [acc::i] => [sp+1] ; sp++
 
 pushb                      - self => [sp+1] ; sp++
 
 pushbi i                   - [self::i] => [sp+1] ; sp++ ;
 
 pushf i                    - fp+i => [sp+1] ; sp++
 
 pushfi i                   - [fp+i] => [sp+1] ; sp++

 pushm                      - mcc => [sp+1] ; sp++;
 
 pushn n                    - n  => [sp+1] ; sp++
 
 pushr r                    - r  => [sp+1] ; sp++
 
 pushsi i                   - [sp+i] => [sp+1] ; sp++

 reserve i                  - exclude part of the stack from managed stack frame ;
                              should follow "open" byte code
 
 swapsi   i                 - [sp+i] <=> [sp]
 
 xpopai                     - [acc:i] <= [sp] ; sp-- ;
                              direct operation       

 register commands:
 ------------------            
 acopyb                     - self => acc
 
 acopyf i                   - fp+i => acc
                              does not affect m register (EDX)           
 
 acopyr r                   - r => acc

 acopys i                   - sp+i => acc
                              does not affect m register (EDX)           
 
 aloadai i                  - [acc::i] => acc
 
 aloadbi i                  - [self::i] => acc

 aloadd                     - [acc::index] => acc
          
 aloadfi i                  - [fp+i] => acc

 aloadr r                   - [r] => acc

 aloadsi i                  - [sp+i] => acc;
                               does not affect m register (EDX)
 
 asavebi i                  - [self::i] <= acc;
                               use GC reference bit masks
 
 asavefi i                  - [fp+i] <= acc 
 
 asaver r                   - [r] <= acc
 
 asavesi i                  - [sp+i] <= acc

 aswapsi i                  - [sp+i] <=> acc
 
 bcopya                     - acc => self
          
 bloadfi i                  - [fp+i] => self
 
 daddai i                   - index += [acc:i]
 
 daddsi n                   - d << d + [sp:i]

 dcopy i                    - i => index
 
 ddec                       - index--

 dinc                       - index++
 
 dloadai i                  - [acc:i] => index
 
 dloadfi i                  - [fp:i] => index

 dloadsi i                  - [sp:i] => index
 
 dsaveai i                  - [acc:i] <= index ;
                              direct operation      
 
 dsavefi i                  - [fp:i] <= index

 dsavesi i                  - [sp:i] <= index

 dsubai i                   - index -= [acc:i]
 
 dsubsi n                   - d << d - [sp:i]

 madd m                     - m + mcc => mcc
 
 maddai i                   - mcc + acc:i => mcc

 mcopy                      - m => mcc
 
 mcopysubj                  - mcc:subj => mcc
 
 mcopyverb                  - mcc:verb => mcc

 mloadai i                  - acc:i => mcc

 mloadfi i                  - [fp+i] => mcc

 mloadsi i                  - [sp+i] => mcc

 msaveai                    - mcc => [acc:i]
 
 msaveparams i              - copy the message parameters;
                              [fp+i]::mcc.param => [sp+1] ; sp++;


 msetverb m                 - m.verb + mcc.subj + m.param_count => mcc
 
 mreset m                   - m + mcc.param_count => mcc

 mresetsubj m               - m + mcc.param_count + mcc.subj => mcc

 scopyf i                   - sp <= fp + i
 
 
 control commands:
 -----------------                     
 breakpoint                 - used for debugging

 close                      - restore the previous frame ;
                              should be paired with open
                              it should be only one command per procedure ; 

 exclude                    - exclude the stack content from managed space

 include                    - restore managed stack
                              (should be paired with exclude)

 open i                     - save the last frame and open the new frame ; 
                              init the frame header offset
                              it should be only one command per procedure ; 

 restore n                  - remove the excluded stack

 
 calling commands:
 -----------------  
 acallvi i                  - call acc::VMT[i] method

 bsredirect                 - search acc::VMT for the message in m;
                              if found jumps to it; binary search is used
                              
 bsgredirect                - foreach o in acc -> search o::VMT for the message in m;
                              if found jumps to it; if not - goes to the next member
                              binary search is used
  
 callextr r                 - calls the external procedure
              
 callr r                    - calls the procedure;
                              acc contains the result
 
 evalr r                    - evaluate a reference ; if r is a symbol reference
                              symbol code is executed ; acc contains the result
 
 mquit                      - terminates the procedure ; clear the stack parameters, based
                              on mcc value

 scallvi i, n               - redirect to [sp+i]::VMT[n] method
 
 quit                       - terminates the procedure;
                              
 quitn                      - terminates the procedure;
                              clear the stack parameters

 xcallrm r, m               - calls directly the method resolved by JIT by r and m
                              acc contains the result


 branching commands:
 ------------------- 
 aelse label                - jumps to the label if acc == 0

 aelser r, label            - jumps to the label if acc != r

 aelsesi i, label           - jumps to the label if acc != [sp+i]

 ajumpvi i                  - redirect to acc::VMT[i] method

 athen label                - jumps to the label if acc != 0
 
 athenr r, label            - jumps to the label if acc == r
 
 athensi i, label           - jumps to the label if acc == [sp+i]

 bstest labErr               - 0 < index < buf:acc.Length
 
 delse label                - jumps to the label if index == 0
 
 delsen n, label            - jumps to the label if index != n
 
 dthen label                - jumps to the label if index != 0
 
 dthenn n, label            - jumps to the label if index == n
  
 elseflag f, label           - jumps to the label if acc.vmt.flag & f != f
 
 jumpr address              - jumps to the address

 jump label                 - jumps to the label

 melse m, label             - jumps to the label if mcc != m

 melseai i, label           - jumps to the label if mcc != acc[i]
 
 melseverb m, label         - jumps to the label if mcc.verb != m
 
 mthen m, label             - jumps to the label if mcc == m
 
 mthenai i, label           - jumps to the label if mcc == acc[i]

 mthenverb m, label         - jumps to the label if mcc.verb == m
 
 next  i, label             - index++; jumps to the label if index < i
 
 test labErr                 - if not 0 < index < acc.Length, jump to the label
 
 testflag f, label           - jumps to the label if acc.vmt.flag & f == f
 
 wstest labErr               - 0 < index < str:acc.Length
 

 exception handling:
 --------------- 
 hook label                 - assign a new exception handler

 throw                      - raise an exception (acc contains the exception object)

 unhook                     - remove the current exception handler

 
 memory managing commands:
 -------------------------
 box vmt                     - if acc is local box its content into the object with vmt and size index

 bscreate                    - create the byte array with size=index and vmt=acc, out : acc  

 create i, vmt               - create the object with the specified
                               number of fields;
                               out: acc contains the class instance

 createn n, vmt              - create the binary object with the 
                               specified size ; acc contains the class instance

 nbox vmt                    - if acc is local box its content into the object with vmt and size index
 
 refcreate                   - create the object with size=index and vmt=acc, out : acc  

 unbox                       - copy acc content into the stack where index=size

 wscreate                    - create the object with size=index and vmt=acc, out : acc  
 

 data manipulating commands:
 -----------------  
 axcopyr r                   - r => [acc::index]                              
                               ; direct
 
 get                         - acc <= self[index] ;

 iaxcopyr i, r               - r => [acc::i]               
                               ; direct

 iaxloadb i                  - self => [acc::i]
                               ; direct
                                
 iaxloadbi i1, i2            - [self::i1] => [acc::i2]
                               ; direct

 iaxloadfi i1, i2            - [fp+i1] => [acc::i2]
                               ; direct
                               
 iaxloadsi i1, i2            - [sp+i1] => [acc::i2]
                               ; direct

 set                         - acc => self[index] ;

 memory managing commands:
 -------------------------


 data manipulating commands:
 -----------------
          
 extension commands:
 -----------------
 indexofmsg                  - search for mcc in acc:VMT; out: index or -1

 ncopy                       - int:self << int:acc

 ncopyword                   - int:self << word:acc

 ncopystr                    - int:self << str:acc, index = radix, convert to int; out: acc=self, index = 0 if failed
 
 nload                       - int:[sp] >> int:acc

 nsave                       - int:[sp] << int:acc

 nequal                      - int(acc) == int([sp]) ? index=1 : index=0
                                                                                         
 nless                       - int(acc) < int([sp]) ? index=1 : index=0

 nnotgreater                 - int(acc) <= int([sp]) ? index=1 : index=0
 
 nadd                        - int(acc) += int([sp])                  

 
 nsub                        - int(acc) -= int([sp])
 
 nmul                        - int(acc) *= int([sp])
 
 ndiv                        - int(acc) /= int([sp])
                                
 nand                        - int(acc) && int([sp]) => [acc]
 
 nor                         - int(acc) || int([sp]) => [acc]
 
 nxor                        - int(acc) ^^ int([sp]) => [acc] 

 nshift                      - acc <<= index

 nnot                        - ~int(acc) >> acc
 
 ninc                        - int(acc)++

 lcopy                       - long:self << long:acc

 lcopyint                    - long:self << int:acc
 
 lcopystr                    - long:self << str:acc, index = radix, convert to long; out: acc=self, index = 0 if failed

 lload                       - long:[sp] >> long:acc

 loadclass                   - self:VMT >> acc

 lsave                       - long:[sp] << long:acc

 lequal                      - long(acc) == long([sp]) ? index=1 : index=0
 
 lless                       - long(acc) < long([sp]) ? index=1 : index=0
                                                                                                                                                     
 lnotgreater                 - long(acc) <= long([sp]) ? index=1 : index=0
 
 ladd                        - long(acc) += long([sp])
 
 lsub                        - long(acc) -= long([sp])
 
 lmul                        - long(acc) *= long([sp])
 
 ldiv                        - long(acc) /= long([sp])

 land                        - long(acc) && long([sp]) => [acc]
 
 lor                         - long(acc) || long([sp]) => [acc]
 
 lxor                        - long(acc) ^^ long([sp]) => [acc]

 lnot                       - ~long:acc >> acc
 
 lshift                      - acc <<= index
 
 rcopy                       - real:self << real:acc
 
 rcopyint                    - real:self << int:acc
 
 rcopylong                   - real:self << long:acc
 
 rcopystr                    - real:self << str:acc, convert to real; out: acc=self, index = 0 if failed
 
 requal                      - long(acc) == long([sp]) ? index=1 : index=0
 
 rless                       - long(acc) < long([sp]) ? index=1 : index=0

 rnotgreater                 - long(acc) <= long([sp]) ? index=1 : index=0
 
 radd                        - real(acc) += real([sp])
 
 rsub                        - real(acc) -= real([sp])
 
 rmul                        - real(acc) *= real([sp])
 
 rdiv                        - real(acc) /= real([sp])
 
 raddint                     - real(acc) += int([sp])
 
 rsubint                      real(acc) -= int([sp])
 
 rmulint                     - real(acc) *= int([sp])
 
 rdivint                     - real(acc) /= int([sp])
 
 raddlong                    - real(acc) += long([sp])
 
 rsublong                    - real(acc) -= long([sp])
 
 rmullong                    - real(acc) *= long([sp])
 
 rdivlong                    - real(acc) /= long([sp])
 
 wsgetlen                    - str(acc).Length >> index
 
 wssetlen                    - str(acc).Length << index

 wscopy                      - self << str:acc
 
 wscopyint                   - convert int(acc) with base=index into ws(self)

 wscopylong                  - convert long(acc) with base=index into ws(self)
 
 wscopyreal                  - convert real(acc) with len=index into ws(self)
 
 wscopybuf                   - self << buf(acc:[sp], index) convert utf8 to utf16

 wssave                      - save str(acc) in the stack; out : acc - reference to saved

 wsreserve                   - allocate the space for acc=widestr

 wsequal                     - str(acc) == str([sp]) ? index=1 : index=0
 
 wsless                      - str(acc) < str([sp]) ? index=1 : index=0
 
 wsnotgreater                - str(acc) <= str([sp]) ? index=1 : index=0
 
 wsadd                       - self += ws(acc)
 
 wsgetat                     - str:acc[index] >> short:[sp]
 
 wssetat                     - str:self[index] << acc

 wsindexofstr                - search for str=[sp] in acc starting with index, out: index or -1

 wscopystr                   - self << str(acc:[sp], index)
 
 wsaddstr                    - self += str(acc:[sp], index)
 
 wsloadname                  - str(self) << acc.VMT.ClassName (only for VM client), max length = index ; out : eax, index - the actual size

 wseval                      - load symbol by name into acc ; str(self) => acc
 
 wsload                      - load acc content into [sp]
 
 bsload                      - load acc content into [sp]

 bssave                      - save acc=bytes in the stack, out : acc - reference to saved

 bsreserve                   - allocate the space for acc=bytearray 

 bssetbuf                    - (self:[sp], index) << acc
 
 bsgetbuf                    - (self:[sp], index) >> acc
 
 bscopystr                   - self << str(acc:[sp], index)
 
 bssetword                   - self:index << word(acc)
 
 bsgetword                   - self:index >> word(acc)
 
 bsindexof                   - search for byte=acc in (self:index, [sp]), out: index or -1

 bsindexofword               - search for byte=acc in (self:index, [sp]), out: index or -1

 bseval                      - executes VM Script tape in self, acc contains the result
 
 bssetlen                    - bytes(acc).Length << index

 bsgetlen                    - bytes(acc).Length >> index

 getlen                      - acc.Length >> index
 
 lrndnew                     - random number init >> long(self)
 
 lrndnext                    - long(self) : index >> acc
 
 rabs                        - self << abs(real:acc)

 rround                      - self << round(real:acc)

 rexp                        - self << exp(real:acc)
                                                                                                     
 rln                         - self << ln(real:acc)
 
 rint                        - self << int(real:acc)
 
 rcos                        - self << cos(real:acc)
 
 rsin                        - self << sin(real:acc)
 
 rarctan                     - self << argtan(real:acc)
 
 rsqrt                       - self << sqrt(real:acc)
 
 rpi                         - self << pi
                                                                                                      
 refgetlenz                  - params(acc).length >> index

 ncall                       - call symbol:acc
 