ELENA byte codes (or ecodes)
==============================

 ELENA virtual machine registers:
 --------------------------------
   f(p)   - frame pointer     (positive values - pointing to the current frame, 
                               negative - to the previous frame)
   s(p)   - stack pointer     (only positive)

   acc    - accumulator      (ebx)

   index  - data accumulator (edx)


 Register operations:
 --------------------
 and n                      - index && n => index
 
 dec i                      - index -= i

 div n                      - index /= n
 
 get                        - acc[index] => acc

 geti i                     - acc <= acc[i] ;

 inc i                      - index += 1
 
 load                       - int[acc] => index

 loadfi i                   - [fp+i] => index

 movm m                     - m => index

 movn n                     - n => index

 movf i                     - fp+i => acc

 movr r                     - r => acc
           
 peekfi i                   - [fp+i] => acc;

 peekr r                    - [r] => acc

 peeksi i                   - [sp+i] => acc;

 save                       - [acc] <= index

 savef i                    - fp+i <= index

 savesi i                   - [sp+i] <= index

 select r1, r2              - acc = (index = 0 ? r1 : r2)

 set i                      - [sp] => acc[index]

 seti i                     - [sp] => acc[i]

 shl n                      - index << n  => index
 
 shr n                      - index >> n  => index
                       
 storefi i                  - [fp+i] <= acc 
 
 storer r                   - [r] <= acc
                       
 storesi i                  - [sp+i] <= acc

 xseti i                    - [sp] => acc[i]; direct operation
                       
 xsetfi i1 i2               - [fp+i1] => acc[i2]; direct operation 


 Memory operations:
 -----------------
 clonef i                   - copy [acc] << fp+i, acc.Length bytes ; NOTE : should support a reference array as well

 copyf  i, n                - copy [acc] << fp+i, n*4-bytes

 copyfi i, n                - copy [acc] << [fp+i], n*4-bytes

 copyto n                   - copy [sp] >> acc[index], n*4-bytes (index ~ dword-aligned)

 copytoai i, n              - copy [sp] >> acc[i], n*4-bytes

 copytof  i, n              - copy [acc] >> fp+i, n*4-bytes

 copytofi i, n              - copy [acc] >> [fp+i], n*4-bytes

 create r                   - create the object with length=[esp], out : acc, index is affected

 createn r, i               - create the object with size=[esp]*i, out : acc, index is affected

 len                        - [acc].Length >> index ; where acc is a object

 read                       - acc[index] >> index

 readtof i, n               - copy acc[index] >> fp+i, n*4-bytes
 
 xsavef i,n                 - fp:i <= n
                                                                                                               
 xwrite n                   - copy [sp] >> acc[index], n-bytes  


 Arithmeric operations:
 ----------------------
 naddf i                    - dword[fp+i] << dword[fp+i] + dword[acc]

 nandf                      - dword[fp+i] << dword[fp+i] && dword[acc]
 
 ndivf i                    - dword[fp+i] << dword[fp+i] / dword[acc]

 nmulf i                    - dword[fp+i] << dword[fp+i] * dword[acc]

 norf                       - dword[fp+i] << dword[fp+i] || dword[acc]

 nshlf i                    - dword[fp+i] << dword[fp+i] $shl dword[acc] 

 nshrf i                    - dword[fp+i] << dword[fp+i] $shr dword[acc] 

 nsubf i                    - dword[fp+i] << dword[fp+i] - dword[acc] 

 nxorf                      - dword[fp+i] << dword[fp+i] ~~ dword[acc]


 Comparision operations:
 ----------------------- 
 equal                       - acc == [sp] ; if true - index = 1, if false - index = 0

 nequal                      - int[acc] == int[sp] ; if true - index = 1, if false - index = 0

 nless                       - int[acc] < int[sp]  ; if true - index = 1, if false - index = 0


 Stack operations:
 -----------------                                           
 alloci i                   - sp+=i;

 freei i                    - sp-=i; 
 
 popa                       - acc <= [sp] ; sp--
 
 pusha                      - acc => [sp+1] ; sp++                  

 pushai i                   - [acc::i] => [sp+1] ; sp++
 
 pushf i                    - fp+i => [sp+1] ; sp++
 
 pushfi i                   - [fp+i] => [sp+1] ; sp++
 
 pushn n                    - n  => [sp+1] ; sp++

 pushr r                    - r  => [sp+1] ; sp++

 pushs i                    - sp+i => [sp+1] ; sp++

 pushsi i                   - [sp+i] => [sp+1] ; sp++
 

 Frame operations:
 -----------------              
 close                      - restore the previous frame ;
                              should be paired with open
                              it should be only one command per procedure ; 
 
 open i                     - save the last frame and open the new frame ; 
                              init the frame header offset
                              it should be only one command per procedure ; 
 
 quit                       - terminates the procedure;
 
 quitn                      - terminates the procedure;
                              clear the stack parameters

 reserve i                  - exclude part of the stack from managed stack frame ;
                              should follow "open" byte code
 
 restore n                  - remove the excluded stack


 Call operations:
 ----------------
 callextr r                 - calls the external procedure ; index contains the result
 
 callr r                    - calls the procedure;
                              acc contains the result
 

 Misc operations:
 ---------------- 
 breakpoint                 - used for debugging

 freelock                   - free [esp]

 hook label                 - assign a new exception handler ; ext affected (*index and ext affected)

 loadenv                    - %SYSTEM_ENV => index 

 nop                        - idle command  

 snop                       - thread safe nop operation
 
 throw                      - raise an exception (acc contains the exception object)

 trylock                    - try to lock [esp], if already locked - index = 1, otherwise index = 0
 
 unhook                     - remove the current exception handler


 Object operations:
 ------------------
 bsredirect                 - search acc::VMT for the message in index;
                              if found jumps to it; binary search is used ; index, acc presaved

 callrm r, m                - calls directly the method resolved by JIT by r and m
                              acc contains the result
 
 callvi i                   - call acc::VMT[i] method

 class                      - acc::VMT >> acc 
 
 fillr r                    - fill the object with the value dword[esp]-times

 fillri r, i                - fill the object with the value i-times

 flag                       - acc::VMT::flag >> index 

 jumprm r, m                - jumps directly the method resolved by JIT by r and m
 
 jumpvi i                   - redirect to acc::VMT[i] method
 
 mtredirect r, m            - search in message table r the message in index and provided parameter list; if found jumps to it;

 new vmt, i                 - create the object with the specified
                               number of fields;
                               out: acc contains the class instance, index - undefined
                               
 newn vmt, n                - create the binary object with the specified size ;
                               out: acc contains the class instance, index - undefined

 vcallrm r, m               - directly resolve message mapping for the specified class
 
 xmtredirect r,m            - search in message table r the message in ext and provided parameter list; if found jumps to direct address;


 Jump operations:
 ---------------- 
 elsen n, label             - jump to the label if index != n
 
 elser r, label             - jumps to the label if acc != r

 jump label                 - jumps to the label
 
 ifn n, label               - jump to the label if index == n
 
 ifr r, label               - jumps to the label if acc == r
 
 lessn n, label             - jump to the label if index < n

 notless label              - jump to the label if acc[0] >= index









 Register operations:
 --------------------
 acopyb                     - base => acc
 
 acopyai i                  - acc+i => acc
                              does not affect ext register (ECX) 

 acopys i                   - sp+i => acc
                              does not affect ext register (ECX)

 address label              - load label address to ext
 
 bcopya                     - acc => base

 bcopyf i                   - fp+i => base                                        
                              does not affect ext register (ECX)           
          
 bcopys i                   - sp+i => base                                        
                              does not affect ext register (ECX)           
          
 bcopyr r                   - r => base
                              
 bswap                      - a <=> b                                              

 copym m                    - ext << message

 dcopy i                    - i => index
 
 dcopycount                 - index << ext.paramcount
 
 dcopye                     - index << ext
 
 dcopyr                     - index << real index
 
 dcopyverb                  - index << ext.verb
 
 dsetverb                   - index >> ext.verb
 
 dmoveverb                  - index.verb >> ext.verb

 ecopy i                    - i => ext
 
 ecopyd                     - ext << index
                              
 eswap                      - index <=> ext
 
 scopyf i                   - sp <= fp + i
 
 setverb m                  - ext.verb << m
 
 xselectr r1, r2            - acc = (acc = 0 ? r1 : r2)
 

 Memory operations:
 -----------------
 aloadai i                  - [acc::i] => acc 

 aloadbi i                  - [base::i] => acc

 asavebi i                  - [base::i] <= acc;
                               use GC reference bit masks
 
 asaver r                   - [r] <= acc
 
 axsavebi i                 - [base::i] <= acc;
                               direct
 
 bloadai i                  - [acc::i] => base

 bloadr r                   - [r] => base

 bread                      - acc[index] >> ext                               
 
 breadb                     - acc[index] >> [byte]ext
 
 bwrite                     - base[index] << ext
 
 bwriteb                    - base[index] << [byte]ext
 
 bwritew                    - base[index] << word[ext]
                  
 copy                       - {base} << {acc}, base.Length (*index, ext affected)

 xcopy                      - {base} << {acc}, base.Length (*index, ext affected) where acc and base are dynamic objects

 copyb                      - {base} >> {acc}, acc.Length

 ncopy                      - int[base] << int[acc]
 
 ncopyb                     - int[base] >> int[acc]
 
 nload                      - int[acc] >> index
  
 nloade                     - int[acc] >> ext
  
 nloadi                     - int[acc+i*4] >> index
 
 lsave                      - long[base] << long index
 
 nread                      - acc[index * 4] >> ext                               
 
 nsavei                     - int[base+i*4] << index
 
 nwrite                     - base[index * 4] << ext
 
 nwritei                    - base[i * 4] << ext
 
 bwritei                    - base[i * 4] << byte[ext]
 
 nreadi                     - acc[i * 4] >> ext
 
 rcopy                      - real index << index
 
 rsave                      - real[base] << real index
 
 set                        - acc => base[index] ; (*ext affected)
                              
 wread                      - [acc][index*2] >> [short]ext

 wwrite                     - [base][index*2] << [short]ext

 xset                       - acc => base[index] ;
                              ; direct


 Stack operations:
 -----------------
 addfi i,n                  - [fp:i] <= [fp:i] + n

 pushe                      - ext => [sp+1] ; sp++;
	
 aloadfi i                  - [fp+i] => acc

 aswapsi i                  - [sp+i] <=> acc

 bloadfi i                  - [fp+i] => base

 bloadsi i                  - [sp+i] => base

 bsavesi i                  - [sp+i] <= base
 
 bswapsi i                  - [sp+i] <=> base

 dloadfi i                  - [fp:i] => index
 
 dloadsi i                  - [sp:i] => index

 dsavefi i                  - [fp:i] <= index

 dswapsi                    - ext <=> [sp:i]
 
 eloadfi i                  - [fp:i] => ext
 
 eloadsi i                  - [sp:i] => ext

 esavefi i                  - [fp:i] <= ext
                              
 esavesi i                  - [sp:i] <= ext
 
 eswapsi                    - ext <=> [sp:i]

 pop                        - sp--; 

 popb                       - base <= [sp] ; sp--
 
 popd                       - index <= [sp] ; sp--
    
 pope                       - ext <= [sp] ; sp--
 
 popi n                     - sp-=i; 
 
 pushb                      - base => [sp+1] ; sp++
 
 pushn n                    - n  => [sp+1] ; sp++
 
 pushd                      - index => [sp+1] ; sp++;

 subfi i,n                  - [fp:i] <= [fp:i] - n


 Call operations:
 ----------------
 call                       - call [acc] procedure

 calli i                     - call [acc+i] procedure

 jumpn n                    - jump [acc+n] procedure
 
 callextr r                 - calls the external procedure ; index contains the result
 

 Jump operations:
 ---------------- 
 else label                 - jump to the label if index != ext
 
 elseb label                - jump to the label if acc != base
 
 elsem m, label             - jump to the label if ext != message
 
 elsen n, label             - jump to the label if index != n
 
 greatern n, label          - jump to the label if index > n
 
 if label                   - jump to the label if index == ext                                                   

 ifheap label               - jump to the label if acc is allocated in heap (more precisely - not in the stack) (*index affected)

 ifm m, label               - jump to the label if ext == message
 
 less label                 - jump to the label if index < ext

 next label                 - index++; if index < ext, jump to the label
 
 notgreatern n, label      - jump to the label if index <= n
 
 notlessn n, label          - jump to the label if index >= n

 
 Object operations:
 ------------------
 acallvd                    - call acc::VMT[index]

 ajumpi i                   - redirect to acc[i] address
 
 bcreate                    - create the object with size=index and vmt=acc, out : acc  (*index and ext affected)
 
 check                      - acc is-instance-of base ? -1 : 0
 
 parent                     - base::Parent >> acc ; returns parent or package depending on the class flag
 
 create                     - create the object with length=index and vmt=acc, out : acc   (*index and ext affected)
 
 len                        - [acc].Count >> index;
 
 count                      - [base].Count >> ext;
 
 mindex                     - search for ext in acc:VMT; out: index or -1
 
 ncreate                    - create the object with size=index*4 and vmt=acc, out : acc   (*index and ext affected)

 newi i                     - create the binary object with the specified size i * reg_size;
                               out: acc contains the class instance

 nlen                       - [acc].Length >> index / 4 ; where acc is a object

 validate                   - validates if acc is not zero, otherwise break the code
                                                                                                                                                
 wcreate                    - create the object with size=index*2 and vmt=acc, out : acc   (*index and ext affected)
 
 wlen                       - [acc].Length / 2 >> index

 xlen                       - [acc].Count >> ext ;


 Misc operations:
 ---------------- 
 rethrow                    - resend the exception to the previous handler, without freeing stack


 Frame operations:
 -----------------              
 equit                      - terminates the procedure ; clear the stack parameters, based
                              on ext

 exclude                    - should be called before external call, excluding the stack starting from ESP from GC frames
 
 init i                     - allocate the stack block for variables and fill it with zero ; acc,base are undefined


 Arithmeric operations:
 ----------------------
 add                        - index += ext

 ande                       - index && ext => index
 
 addn n                     - index += n
 
 eaddn                      - ext += n

 eorn n                     - ext || n

 ladd                       - long[base] += long[acc]
 
 land                       - long[base] && long[acc]   (*index and ext affected)
 
 lcopy                      - long[base] << long[acc]

 lcopyb                     - long[base] >> long[acc]

 ldiv                       - long[base] /= long[acc]   (*index and ext affected)
 
 lmul                       - long[base] *= long[acc]   (*index and ext affected)
 
 lnot                       - long[base] << not long[acc]
 
 lor                        - long[base] || long[acc]    (*index and ext affected)
 
 lshiftl                    - long[base] <<= index       (*index and ext affected)
 
 lshiftr                    - long[base] >>= index       (*index and ext affected)
 
 lsub                       - long[base] -= long[acc]
 
 lxor                       - long[base] ~~ long[acc]     (*index and ext affected)

 muln n                     - index * n => index
 
 nnot                       - int[base] << not int[acc]
 
 not                        - !index => index
 
 nshiftl                    - int[base] <<= index
 
 nshiftr                    - int[base] >>= index
 
 or                         - index || ext => index

 orn n                      - index || n => index
 
 rabs                       - base << abs(real:acc)
 
 radd                       - real[base] += real[acc]

 rdiv                       - real[base] /= real[acc]

 rexp                       - base << exp(real:acc)
 
 rint                       - base << int(real:acc)
                                                                                                     
 rln                        - base << ln(real:acc)

 rload                      - real index << real[acc]
 
 rmul                       - real[base] *= real[acc]

 rround                     - base << round(real:acc)

 rsub                       - real[base] -= real[acc]

 shiftln n                  - index << n  => index
 
 shiftrn n                  - index >> n  => index
 
 sub                        - index -= ext


 Comparision operations:
 ----------------------- 
 lequal                     - long[acc] == long[base] ; if true - index = 1, if false - index = 0

 lless                      - long[acc] < [base] ; if true - index = 1, if false - index = 0
 
 requal                     - real[acc] == real[base] ; if true - index = 1, if false - index = 0
 
 rless                      - real[acc] < real[base] ; if true - index = 1, if false - index = 0

 equalr r                   - acc == r ; if true - index = 1, if false - index = 0
