/// a program which parses and evaluates arithmetic expressions. 

import system'routines.
import extensions.
import extensions'text.

// --- Token ---

class Token
{
    object                theValue.
    
    object rprop level :: theLevel.
    
    constructor new level:aLevel
    [
        theValue := StringWriter new.
        theLevel := aLevel + 9.
    ]
    
    append : aChar
    [
        theValue << aChar.
    ]
    
    number = theValue get; toReal.
}

// --- Node ---

class Node
{
    object prop  left  :: theLeft.
    object prop  right :: theRight.
    object rprop level :: theLevel.

    constructor new level:aLevel
    [
        theLevel := aLevel.
    ]
}

// --- SummaryNode

class SummaryNode :: Node
{
    constructor new level:aLevel
        <= new level(aLevel + 1).
    
    number = theLeft number + theRight number.
}

// --- DifferenceNode ---

class DifferenceNode :: Node
{
    constructor new level:aLevel
        <= new level(aLevel + 1).
    
    number = theLeft number - theRight number.
}

// --- ProductNode ---

class ProductNode :: Node
{
    constructor new level:aLevel
        <= new level(aLevel + 2).
    
    number = theLeft number * theRight number.
}

// --- FractionNode ---

class FractionNode :: Node
{
    constructor new level:aLevel
        <= new level(aLevel + 2).
    
    number = theLeft number / theRight number.
}

// --- Expression ---

class Expression
{
    object rprop level :: theLevel.
    object prop  top   :: theTop.
    
    constructor new level:aLevel
    [
        theLevel := aLevel
    ]
    
    right = theTop.

    set right:aNode [ theTop := aNode ]
    
    number => theTop.
}

// --- States ---

operatorState : ch
[
    ch =>
        $40 [      // (
            ^ self newBracket; gotoStarting
        ];
        ! [
            ^ self newToken; append:ch; gotoToken
        ].
]

tokenState : ch
[
    ch =>
        $41 [      // )
            ^ self closeBracket; gotoToken
        ];
        $42 [      // *
            ^ self newProduct; gotoOperator
        ];
        $43 [      // +
            ^ self newSummary; gotoOperator
        ];
        $45 [      // -
            ^ self newDifference; gotoOperator
        ];
        $47 [      // /
            ^ self newFraction; gotoOperator
        ];
        ! [
            ^ self append:ch
        ].
]

startState : ch
[
    ch =>
        $40 [      // (
            ^ self newBracket; gotoStarting
        ];
        $45 [ // -
            ^ self newToken; append literal:"0"; newDifference; gotoOperator
        ];
        ! [
            ^ self newToken; append:ch; gotoToken
        ].
]

// --- Scope ---

class Scope
{
    object theState.
    object theLevel.
    object theParser.
    object theToken.
    object theExpression.
    
    constructor new parser:aParser
    [
        theState := startState.
        theLevel := 0.
        theExpression := Expression new level:0.
        theParser := aParser.
    ]
                                       
    newToken
    [
        theToken := theParser appendToken expression:theExpression level:theLevel.
    ]                                                
    
    newSummary
    [
        theToken := nil.
        
        theParser appendSummary expression:theExpression level:theLevel.
    ]                                                
    
    newDifference
    [
        theToken := nil.
        
        theParser appendDifference expression:theExpression level:theLevel
    ]                                                
      
    newProduct
    [
        theToken := nil.
        
        theParser appendProduct expression:theExpression level:theLevel
    ]                                                
    
    newFraction
    [
        theToken := nil.
        
        theParser appendFraction expression:theExpression level:theLevel
    ]                                                

    newBracket
    [
        theToken := nil.
        
        theLevel := theLevel + 10.
        
        theParser appendSubexpression expression:theExpression level:theLevel.
    ]            

    closeBracket
    [
        if (theLevel < 10)
            [ InvalidArgumentException new:"Invalid expression"; raise ].
        
        theLevel := theLevel - 10
    ]            
                                    
    append:ch
    [
        if((ch >= $48) && (ch < $58))
            [ theToken append:ch ];
            [ InvalidArgumentException new:"Invalid expression"; raise ]
    ]
            
    append literal:aLiteral
    [
        aLiteral forEach(:ch)[ self append:ch ]
    ]
                                                         
    gotoStarting
    [
        theState := startState
    ]
                                                                  
    gotoToken
    [
        theState := tokenState
    ]
                                                                  
    gotoOperator
    [
        theState := operatorState
    ]
    
    number => theExpression.
    
    dispatch => theState.
}

// ---- Parser ----

class Parser
{
    appendToken expression:anExpression level:aLevel
    [
        var aToken := Token new level:aLevel.
        
        anExpression set top:($self append last(anExpression top) new:aToken).
        
        ^ aToken
    ]

    appendSummary expression:anExpression level:aLevel
    [
        anExpression set top($self append last(anExpression top) new(SummaryNode new level:aLevel)).
    ]

    appendDifference expression:anExpression level:aLevel
    [
        anExpression set top($self append last(anExpression top) new(DifferenceNode new level:aLevel)).
    ]

    appendProduct expression:anExpression level:aLevel
    [
        anExpression set top($self append last(anExpression top) new(ProductNode new level:aLevel)).
    ]

    appendFraction expression:anExpression level:aLevel
    [
        anExpression set top($self append last(anExpression top) new(FractionNode new level:aLevel))
    ]

    appendSubexpression expression:anExpression level:aLevel
    [
        anExpression set top($self append last(anExpression top) new(Expression new level:aLevel)).
    ]

    append last:aLastNode new:aNewNode
    [
        if($nil == aLastNode)
            [ ^ aNewNode ].
        
        if (aNewNode level <= aLastNode level)
            [ aNewNode set left:aLastNode. ^ aNewNode ].
            
        var aParent := aLastNode.
        var aCurrent := aLastNode right.
        while (($nil != aCurrent) && (aNewNode level > aCurrent level))
            [ aParent := aCurrent. aCurrent := aCurrent right. ].
        
        if ($nil == aCurrent)
            [ aParent set right:aNewNode. ];
            [ aNewNode set left:aCurrent. aParent set right:aNewNode ].
            
        ^ aLastNode
    ]
    
    run : aText
    [
        var aScope := Scope new parser:$self.

        aText forEach(:ch)[ aScope eval:ch ].

        ^ aScope number
    ]
}

program =
[
    var aText := String new.
    var aParser := Parser new.

    $(console readLine; saveTo:aText; length > 0) doWhile:
    [
        try(console printLine("=",aParser run:aText))
        {
            on(Exception e)
            [
                console writeLine:"Invalid Expression"
            ]
        }.
                
        aText clear
    ].
].