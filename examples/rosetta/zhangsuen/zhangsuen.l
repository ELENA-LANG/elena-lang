import system'collections;
import system'routines;
import extensions;
import extensions'routines;

const string[] image = new string[]{
        "                                                          ",
        " #################                   #############        ",
        " ##################               ################        ",
        " ###################            ##################        ",
        " ########     #######          ###################        ",
        "   ######     #######         #######       ######        ",
        "   ######     #######        #######                      ",
        "   #################         #######                      ",
        "   ################          #######                      ",
        "   #################         #######                      ",
        "   ######     #######        #######                      ",
        "   ######     #######        #######                      ",
        "   ######     #######         #######       ######        ",
        " ########     #######          ###################        ",
        " ########     ####### ######    ################## ###### ",
        " ########     ####### ######      ################ ###### ",
        " ########     ####### ######         ############# ###### ",
        "                                                          "};

int[][] nbrs = new int[][]
{
    new int[]{0, -1}, new int[]{1, -1}, new int[]{1, 0},   new int[]{1, 1}, new int[]{0, 1},
    new int[]{-1, 1}, new int[]{-1, 0}, new int[]{-1, -1}, new int[]{0, -1}
};

int[][][] nbrGroups = new int[][][]
{
    new int[][]{new int[]{0, 2, 4}, new int[]{2, 4, 6}}, 
    new int[][]{new int[]{0, 2, 6}, new int[]{0, 4, 6}}
};

extension zhangsuenOp : Matrix<CharValue>
{
    proceed(r, c, toWhite, firstStep)
    {
        if (self[r][c] != $35)
            { ^ false };
 
        int nn := self.numNeighbors(r,c);
 
        if ((nn < 2) || (nn > 6))
            { ^ false };
 
        if(self.numTransitions(r,c) != 1)
            { ^ false };
 
        ifnot (self.atLeastOneIsWhite(r,c,firstStep iif(0,1)))
            { ^ false };
 
        toWhite.append(new { x = c; y = r; });
 
        ^ true
    }
 
    numNeighbors(r,c)
    {
        int count := 0;
 
        for (int i := 0, i < nbsr.Length, i += 1)
        {
            if (self[r + nbrs[i][1]][c + nbrs[i][0]] == $35)
                { count += 1 }
        };
 
        ^ count;
    }
 
    numTransitions(r,c)
    [
        int count := 0.
 
        0 till(nbrs length - 1) do(:i)
        [
            if (self[r + nbrs[i][1]][c + nbrs[i][0]] == $32)
            [
                if (self[r + nbrs[i + 1][1]][c + nbrs[i + 1][0]] == $35)
                [
                    count := count + 1.
                ].
            ].
        ].
 
        ^ count.
    ]  
 
    atLeastOneIsWhite(r, c, step)
    [
        int count := 0.
        var group := nbrGroups[step].
        0 till:2 do(:i)
        [            
            0 till(group[i] length) seek(:j)
            [
                var nbr := nbrs[group[i][j]].
 
                if (self[r + nbr[1]][c + nbr[0]] == $32)
                    [ count := count + 1. ^ true ].
 
                ^ false.                    
            ].
        ].
 
        ^ count > 1.
    ]    
 
    thinImage
    [
        bool firstStep := false.
        bool hasChanged := true.
        var toWhite := List new.
 
        while (hasChanged || firstStep)
        [
            hasChanged := false.
            firstStep := firstStep inverted.
 
            1 till(self rows - 1) do(:r) 
            [
                1 till(self columns - 1) do(:c)
                [
                    if(self proceed(r,c,toWhite,firstStep))
                        [ hasChanged := true ].
                ].
            ].
 
            toWhite forEach(:p)[ self[p y][p x] := $32. ].                
            toWhite clear.
        ].
    ]
 
    print
    [
        var it := self enumerator.
 
        it forEach(:ch) [ console print(ch," ") ].
        while (it next)
        [
            console writeLine.
 
            it forEach(:ch) [ console print(ch," ") ].
        ].
    ]
}
 
public program()
{
    Matrix<CharValue> grid := MatrixSpace::
    {
        int rows = image length.
 
        int columns = image[0] length.
 
        getAt(int i, int j)
            = image[i][j].
 
        setAt(int i, int j, object o)
        [
            image[i][j] := o.
        ]
    }.
 
    grid thinImage.
 
    grid print.
 
    console.readChar()
}